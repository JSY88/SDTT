<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>사라지는 텍스트 훈련</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 0; 
            padding: 5px; 
            transition: opacity 0.3s; 
            background-color: #f5f5f5; 
            overscroll-behavior: none; 
            position: relative; 
            touch-action: pan-y; 
        }
        #textContent { 
            font-size: 18px; 
            line-height: 1.6; 
            white-space: pre-wrap; 
            position: relative; 
            overflow-y: hidden; 
            width: 100%; 
            height: calc(70vh - 80px); 
            margin: 0 auto; 
            padding: 10px; 
            box-sizing: border-box; 
            background-color: #fff; 
            border: 1px solid #ddd; 
            border-radius: 8px; 
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); 
            z-index: 1; 
            transition: transform 0.3s ease, background-color 0.3s; 
            color: #333; 
        }
        #controls { 
            margin: 10px 0; 
            display: flex; 
            flex-wrap: wrap; 
            gap: 5px; 
            justify-content: center; 
        }
        #message { 
            color: red; 
            position: fixed; 
            bottom: 20px; 
            left: 50%; 
            transform: translateX(-50%); 
            background: rgba(255, 255, 255, 0.9); 
            padding: 5px 10px; 
            border-radius: 5px; 
            z-index: 10; 
            display: none; 
        }
        #pageInfo { 
            position: fixed; 
            bottom: 10px; 
            right: 10px; 
            font-size: 14px; 
            background: rgba(255, 255, 255, 0.9); 
            padding: 3px 8px; 
            border-radius: 5px; 
            z-index: 10; 
        }
        #progress { 
            width: 100%; 
            height: 4px; 
            margin: 5px 0; 
            opacity: 0.7; 
            transition: background-color 0.3s; 
        }
        #loadingSpinner { 
            display: none; 
            visibility: hidden; 
            opacity: 0; 
            position: fixed; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            width: 20px; 
            height: 20px; 
            border: 3px solid #f3f3f3; 
            border-top: 3px solid #3498db; 
            border-radius: 50%; 
            animation: spin 1s linear infinite; 
            z-index: 5; 
        }
        button { 
            padding: 8px 12px; 
            font-size: 14px; 
            border: none; 
            border-radius: 5px; 
            background-color: #3498db; 
            color: white; 
            cursor: pointer; 
            transition: background-color 0.3s, transform 0.1s; 
            max-width: 100px; 
        }
        button:hover { 
            background-color: #2980b9; 
            transform: scale(1.05); 
        }
        button:focus { 
            outline: 2px solid #2980b9; 
            outline-offset: 2px; 
        }
        button:disabled { 
            opacity: 0.5; 
            cursor: not-allowed; 
        }
        details { 
            margin: 10px 0; 
            width: 100%; 
        }
        summary { 
            padding: 10px; 
            background-color: #ecf0f1; 
            border-radius: 5px; 
            cursor: pointer; 
        }
        .char-span { 
            transition: opacity 0.3s, color 0.3s; 
            color: inherit; 
        }
        .char-span.current { 
            background-color: rgba(255, 255, 0, 0.3); 
        }
        .line { 
            display: block; 
            transition: opacity 0.2s; 
        }
        .line.hidden { 
            opacity: 0; 
        }
        .fullscreen #controls, .fullscreen #progress, .fullscreen #message, .fullscreen details { 
            display: none; 
        }
        .fullscreen #textContent { 
            width: 100vw; 
            height: 100vh; 
            margin: 0; 
            padding: 20px; 
        }
        #fileUpload { 
            display: block; 
            width: 100%; 
            padding: 15px; 
            margin: 10px 0; 
            border: 2px dashed #3498db; 
            border-radius: 5px; 
            text-align: center; 
            font-size: 16px; 
            background-color: #f9f9f9; 
            cursor: pointer; 
            transition: background-color 0.3s; 
        }
        #fileUpload:hover { 
            background-color: #e6f0fa; 
        }
        @keyframes spin { 
            0% { transform: translate(-50%, -50%) rotate(0deg); } 
            100% { transform: translate(-50%, -50%) rotate(360deg); } 
        }
        @media (max-width: 600px) {
            body { padding: 5px; }
            #textContent { 
                font-size: 16px; 
                height: calc(60vh - 60px); 
                padding: 8px; 
            }
            #controls { 
                flex-direction: column; 
                gap: 3px; 
            }
            button { 
                padding: 8px 12px; 
                font-size: 14px; 
                max-width: 100%; 
            }
            #advancedControls { 
                display: flex; 
                flex-direction: column; 
                gap: 8px; 
                padding: 8px; 
            }
            input, select { 
                width: 100%; 
                padding: 8px; 
                font-size: 14px; 
                box-sizing: border-box; 
            }
            #progress { 
                height: 3px; 
            }
            #pageInfo { 
                font-size: 12px; 
                bottom: 5px; 
                right: 5px; 
            }
            #message { 
                bottom: 60px; 
                font-size: 14px; 
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://unpkg.com/epubjs/dist/epub.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
</head>
<body>
    <input type="file" id="fileUpload" accept=".txt,.epub" aria-label="파일 업로드" multiple>
    <div id="controls" role="toolbar">
        <button id="startButton" aria-label="훈련 시작">
            <span class="icon">▶</span> 시작
        </button>
        <button id="stopButton" aria-label="훈련 중지">
            <span class="icon">■</span> 정지
        </button>
        <button id="prevPage" aria-label="이전 페이지">
            <span class="icon">◀</span> 이전
        </button>
        <button id="nextPage" aria-label="다음 페이지">
            <span class="icon">▶</span> 다음
        </button>
    </div>
    <details>
        <summary>고급 설정</summary>
        <div id="advancedControls">
            <label for="speedControl">속도 (빠름: 50ms ~ 느림: 2000ms):</label>
            <input type="range" id="speedControl" min="50" max="2000" step="10" value="100">
            <label for="speedPreset">속도 프리셋:</label>
            <select id="speedPreset">
                <option value="50">빠르게</option>
                <option value="100" selected>보통</option>
                <option value="200">느리게</option>
            </select>
            <label for="effectSelect">효과 선택:</label>
            <select id="effectSelect">
                <option value="char" selected>글자 단위 소멸</option>
                <option value="fade">페이드 아웃</option>
                <option value="eink">전자잉크 모드</option>
            </select>
            <label for="fontSize">글꼴 크기:</label>
            <input type="number" id="fontSize" min="12" max="36" value="18">px
            <label for="fontFamily">글꼴 스타일:</label>
            <select id="fontFamily">
                <option value="Arial, sans-serif">Arial</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="'Noto Sans KR', sans-serif">Noto Sans KR</option>
            </select>
            <label for="lineHeight">줄 간격:</label>
            <input type="number" id="lineHeight" min="1" max="3" step="0.1" value="1.6">
            <label for="letterSpacing">글자 간격:</label>
            <input type="number" id="letterSpacing" min="0" max="5" step="0.1" value="0">px
            <label for="autoRestart">페이지 전환 시 재시작:</label>
            <input type="checkbox" id="autoRestart">
            <label for="pageAnimation">페이지 전환 애니메이션:</label>
            <input type="checkbox" id="pageAnimation" checked>
            <label for="showPageInfo">페이지 번호 표시:</label>
            <input type="checkbox" id="showPageInfo" checked>
            <label for="fullscreenMode">전체 화면 모드:</label>
            <input type="checkbox" id="fullscreenMode">
            <label for="marginTop">위쪽 여백 (%):</label>
            <input type="number" id="marginTop" min="0" max="50" value="0" step="1">
            <label for="marginRight">오른쪽 여백 (%):</label>
            <input type="number" id="marginRight" min="0" max="50" value="0" step="1">
            <label for="marginBottom">아래쪽 여백 (%):</label>
            <input type="number" id="marginBottom" min="0" max="50" value="0" step="1">
            <label for="marginLeft">왼쪽 여백 (%):</label>
            <input type="number" id="marginLeft" min="0" max="50" value="0" step="1">
            <button id="resetSettings" aria-label="설정 초기화">설정 초기화</button>
        </div>
    </details>
    <progress id="progress" value="0" max="100"></progress>
    <div id="textContent" role="region" aria-label="텍스트 표시 영역">
        <div id="pageInfo" aria-live="polite"></div>
    </div>
    <div id="loadingSpinner"></div>
    <div id="message" aria-live="assertive"></div>

    <script>
        const fileInput = document.getElementById('fileUpload');
        const textContent = document.getElementById('textContent');
        const speedControl = document.getElementById('speedControl');
        const speedPreset = document.getElementById('speedPreset');
        const effectSelect = document.getElementById('effectSelect');
        const fontSize = document.getElementById('fontSize');
        const fontFamily = document.getElementById('fontFamily');
        const lineHeight = document.getElementById('lineHeight');
        const letterSpacing = document.getElementById('letterSpacing');
        const autoRestart = document.getElementById('autoRestart');
        const pageAnimation = document.getElementById('pageAnimation');
        const showPageInfo = document.getElementById('showPageInfo');
        const fullscreenMode = document.getElementById('fullscreenMode');
        const marginTop = document.getElementById('marginTop');
        const marginRight = document.getElementById('marginRight');
        const marginBottom = document.getElementById('marginBottom');
        const marginLeft = document.getElementById('marginLeft');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const prevPage = document.getElementById('prevPage');
        const nextPage = document.getElementById('nextPage');
        const pageInfo = document.getElementById('pageInfo');
        const message = document.getElementById('message');
        const progress = document.getElementById('progress');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const resetSettings = document.getElementById('resetSettings');
        let interval, pages = [], currentPage = 0, book;
        let worker;
        let renderedPages = [];

        // 설정 로드
        speedControl.value = localStorage.getItem('speed') || 100;
        speedPreset.value = localStorage.getItem('speedPreset') || 100;
        effectSelect.value = localStorage.getItem('effect') || 'char';
        fontSize.value = localStorage.getItem('fontSize') || 18;
        fontFamily.value = localStorage.getItem('fontFamily') || 'Arial, sans-serif';
        lineHeight.value = localStorage.getItem('lineHeight') || 1.6;
        letterSpacing.value = localStorage.getItem('letterSpacing') || 0;
        autoRestart.checked = localStorage.getItem('autoRestart') === 'true';
        pageAnimation.checked = localStorage.getItem('pageAnimation') !== 'false';
        showPageInfo.checked = localStorage.getItem('showPageInfo') !== 'false';
        fullscreenMode.checked = localStorage.getItem('fullscreenMode') === 'true';
        marginTop.value = localStorage.getItem('marginTop') || 0;
        marginRight.value = localStorage.getItem('marginRight') || 0;
        marginBottom.value = localStorage.getItem('marginBottom') || 0;
        marginLeft.value = localStorage.getItem('marginLeft') || 0;
        updateTextContentStyles();

        // 웹 워커 초기화 (DOM 접근 제거)
        if (window.Worker) {
            worker = new Worker(URL.createObjectURL(new Blob([`
                self.onmessage = function(e) {
                    const { text, maxHeight } = e.data;
                    const lines = text.split('\n').filter(line => line.trim().length > 0);
                    const pages = [];
                    let currentPageText = '';
                    // 단순한 길이 기반 분할 (DOM 없이 대략적인 분할)
                    const maxLinesPerPage = Math.floor(maxHeight / 20); // 대략적인 줄 수 추정 (20px per line)
                    for (let line of lines) {
                        if (currentPageText.split('\n').length >= maxLinesPerPage) {
                            pages.push(currentPageText.trim());
                            currentPageText = line + '\n';
                        } else {
                            currentPageText += line + '\n';
                        }
                    }
                    if (currentPageText.trim().length > 0) pages.push(currentPageText.trim());
                    self.postMessage({ pages });
                };
            `], { type: 'application/javascript' })));
        }

        fileInput.addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (!file) {
                message.innerText = '파일을 선택해주세요.';
                message.style.display = 'block';
                loadingSpinner.style.display = 'none';
                return;
            }

            textContent.style.opacity = 1;
            message.innerText = '파일 로딩 중...';
            message.style.display = 'block';
            progress.value = 0;
            toggleButtons(true);
            loadingSpinner.style.display = 'block';
            loadingSpinner.style.visibility = 'visible';
            loadingSpinner.style.opacity = 1;

            const reader = new FileReader();
            reader.onload = function(event) {
                const fileData = event.target.result;
                console.log('File data loaded:', fileData.substring(0, 100)); // 디버깅 로그
                if (file.name.endsWith('.txt')) {
                    if (worker) {
                        worker.onmessage = function(e) {
                            console.log('Worker response:', e.data);
                            if (e.data.error) {
                                message.innerText = e.data.error;
                                message.style.display = 'block';
                                toggleButtons(false);
                                loadingSpinner.style.display = 'none';
                                loadingSpinner.style.visibility = 'hidden';
                                loadingSpinner.style.opacity = 0;
                                return;
                            }
                            pages = e.data.pages;
                            preloadPages();
                            currentPage = 0;
                            displayPage();
                            message.style.display = 'none';
                            progress.value = 0;
                            toggleButtons(false);
                            loadingSpinner.style.display = 'none';
                            loadingSpinner.style.visibility = 'hidden';
                            loadingSpinner.style.opacity = 0;
                        };
                        worker.onerror = function(e) {
                            console.error('Worker error:', e.message);
                            message.innerText = '웹 워커 오류: ' + e.message;
                            message.style.display = 'block';
                            toggleButtons(false);
                            loadingSpinner.style.display = 'none';
                            loadingSpinner.style.visibility = 'hidden';
                            loadingSpinner.style.opacity = 0;
                        };
                        worker.postMessage({ text: fileData, maxHeight: textContent.getBoundingClientRect().height });
                    } else {
                        pages = splitTextToFit(fileData, textContent.getBoundingClientRect().height);
                        preloadPages();
                        currentPage = 0;
                        displayPage();
                        message.style.display = 'none';
                        progress.value = 0;
                        toggleButtons(false);
                        loadingSpinner.style.display = 'none';
                        loadingSpinner.style.visibility = 'hidden';
                        loadingSpinner.style.opacity = 0;
                    }
                } else if (file.name.endsWith('.epub')) {
                    if (!window.ePub || !window.JSZip) {
                        message.innerText = 'epub.js 또는 JSZip 로딩 실패. 네트워크를 확인하세요.';
                        message.style.display = 'block';
                        console.error('Required libraries not loaded.');
                        toggleButtons(false);
                        loadingSpinner.style.display = 'none';
                        loadingSpinner.style.visibility = 'hidden';
                        loadingSpinner.style.opacity = 0;
                        return;
                    }
                    try {
                        book = window.ePub(fileData);
                        book.ready.then(() => {
                            console.log('EPUB loaded:', book);
                            message.innerText = 'EPUB 파싱 중...';
                            message.style.display = 'block';
                            loadEpubPages().then(pagesData => {
                                pages = pagesData;
                                preloadPages();
                                currentPage = 0;
                                displayPage();
                                message.style.display = 'none';
                                progress.value = 0;
                                toggleButtons(false);
                                loadingSpinner.style.display = 'none';
                                loadingSpinner.style.visibility = 'hidden';
                                loadingSpinner.style.opacity = 0;
                            }).catch(err => {
                                message.innerText = 'EPUB 파싱 실패: ' + err.message;
                                message.style.display = 'block';
                                toggleButtons(false);
                                loadingSpinner.style.display = 'none';
                                loadingSpinner.style.visibility = 'hidden';
                                loadingSpinner.style.opacity = 0;
                            });
                        }).catch(err => {
                            message.innerText = 'EPUB 로딩 실패: ' + err.message;
                            message.style.display = 'block';
                            toggleButtons(false);
                            loadingSpinner.style.display = 'none';
                            loadingSpinner.style.visibility = 'hidden';
                            loadingSpinner.style.opacity = 0;
                        });
                    } catch (err) {
                        message.innerText = 'EPUB 처리 오류: ' + err.message;
                        message.style.display = 'block';
                        toggleButtons(false);
                        loadingSpinner.style.display = 'none';
                        loadingSpinner.style.visibility = 'hidden';
                        loadingSpinner.style.opacity = 0;
                    }
                } else {
                    message.innerText = '지원되지 않는 파일 형식입니다. .txt 또는 .epub 파일을 선택해주세요.';
                    message.style.display = 'block';
                    toggleButtons(false);
                    loadingSpinner.style.display = 'none';
                    loadingSpinner.style.visibility = 'hidden';
                    loadingSpinner.style.opacity = 0;
                }
            };
            reader.onerror = function() {
                message.innerText = '파일 읽기 오류: 파일에 접근할 수 없습니다. 파일을 Download 폴더에 저장하거나 다른 위치를 선택해주세요.';
                message.style.display = 'block';
                toggleButtons(false);
                loadingSpinner.style.display = 'none';
                loadingSpinner.style.visibility = 'hidden';
                loadingSpinner.style.opacity = 0;
            };
            if (file.name.endsWith('.txt')) {
                reader.readAsText(file, 'UTF-8'); // 인코딩 명시
            } else if (file.name.endsWith('.epub')) {
                reader.readAsArrayBuffer(file);
            }
        });

        async function loadEpubPages() {
            if (book && book.rendition) {
                book.rendition.destroy();
            }
            const allPages = [];
            let loadedCount = 0;
            const sections = book.spine.items;
            console.log('Total sections:', sections.length);
            let fullText = '';

            for (let i = 0; i < sections.length; i++) {
                const section = book.spine.get(i);
                try {
                    const content = await section.load(book.load.bind(book));
                    loadedCount++;
                    progress.value = (loadedCount / sections.length) * 50;
                    const div = document.createElement('div');
                    div.appendChild(content.cloneNode(true));
                    const text = div.innerText.trim();
                    if (text) fullText += text + '\n\n';
                } catch (err) {
                    console.error('Section load error:', err);
                    throw new Error('EPUB 섹션 로드 실패: ' + err.message);
                }
            }
            return splitTextToFit(fullText, textContent.getBoundingClientRect().height);
        }

        function splitTextToFit(text, containerHeight) {
            const lines = text.split('\n').filter(line => line.trim().length > 0);
            const pages = [];
            let currentPageText = '';
            const testDiv = document.createElement('div');
            testDiv.style.cssText = `font-size: ${fontSize.value}px; line-height: ${lineHeight.value}; white-space: pre-wrap; visibility: hidden; position: absolute; padding: 10px; font-family: ${fontFamily.value}; letter-spacing: ${letterSpacing.value}px;`;
            document.body.appendChild(testDiv);

            for (let line of lines) {
                testDiv.innerText = currentPageText + line + '\n';
                const boundingRect = testDiv.getBoundingClientRect();
                if (boundingRect.height > containerHeight) {
                    pages.push(currentPageText.trim());
                    currentPageText = line + '\n';
                } else {
                    currentPageText += line + '\n';
                }
            }
            if (currentPageText.trim().length > 0) pages.push(currentPageText.trim());
            document.body.removeChild(testDiv);
            return pages;
        }

        function preloadPages() {
            renderedPages = [];
            const start = Math.max(0, currentPage - 5);
            const end = Math.min(pages.length, currentPage + 6);
            for (let i = start; i < end; i++) {
                const text = pages[i];
                const lines = text.split('\n').filter(line => line.trim().length > 0);
                const html = lines.map(line => {
                    const chars = line.split('');
                    return `<div class="line">${chars.map(char => {
                        return char.trim() === '' ? `<span class="char-span char-space">${char}</span>` : `<span class="char-span">${char}</span>`;
                    }).join('')}</div>`;
                }).join('');
                renderedPages[i] = html;
            }
        }

        function displayPage(direction = 0) {
            const startTime = performance.now();
            if (!renderedPages[currentPage]) {
                loadingSpinner.style.display = 'block';
                loadingSpinner.style.visibility = 'visible';
                loadingSpinner.style.opacity = 1;
            }

            if (pageAnimation.checked && direction !== 0) {
                textContent.style.transform = direction > 0 ? 'translateX(-100%)' : 'translateX(100%)';
                textContent.style.opacity = 0;
            }

            setTimeout(() => {
                textContent.innerHTML = renderedPages[currentPage] || '';
                updateTextContentStyles();
                pageInfo.innerText = showPageInfo.checked ? `${currentPage + 1} / ${pages.length}` : '';
                progress.value = 0;

                const endTime = performance.now();
                const loadTime = endTime - startTime;
                if (loadTime < 100) {
                    loadingSpinner.style.display = 'none';
                    loadingSpinner.style.visibility = 'hidden';
                    loadingSpinner.style.opacity = 0;
                }

                if (pageAnimation.checked) {
                    textContent.style.transform = 'translateX(0)';
                    textContent.style.opacity = 1;
                    setTimeout(() => {
                        if (autoRestart.checked && interval) startEffect();
                    }, 300);
                } else if (autoRestart.checked && interval) startEffect();

                preloadPages();
            }, 50);
        }

        startButton.addEventListener('click', () => {
            if (fullscreenMode.checked) {
                const fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
                const requestFullscreen = document.documentElement.requestFullscreen || document.documentElement.webkitRequestFullscreen || document.documentElement.mozRequestFullScreen || document.documentElement.msRequestFullscreen;
                if (!fullscreenElement && requestFullscreen) {
                    requestFullscreen.call(document.documentElement).then(() => {
                        document.body.style.opacity = 0;
                        setTimeout(() => {
                            document.body.classList.add('fullscreen');
                            document.body.style.opacity = 1;
                        }, 300);
                    }).catch(err => console.error('Fullscreen error:', err));
                }
            }
            startEffect();
        });

        stopButton.addEventListener('click', () => {
            stopEffect();
            const fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
            const exitFullscreen = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen;
            if (fullscreenElement && exitFullscreen) {
                document.body.style.opacity = 0;
                setTimeout(() => {
                    exitFullscreen.call(document).then(() => {
                        document.body.classList.remove('fullscreen');
                        document.body.style.opacity = 1;
                    });
                }, 300);
            }
        });

        speedControl.addEventListener('input', () => {
            speedPreset.value = speedControl.value;
            adjustSpeed();
            if (!interval) previewEffect();
            localStorage.setItem('speed', speedControl.value);
        });

        speedPreset.addEventListener('change', () => {
            speedControl.value = speedPreset.value;
            adjustSpeed();
            if (!interval) previewEffect();
            localStorage.setItem('speedPreset', speedPreset.value);
        });

        effectSelect.addEventListener('change', () => {
            stopEffect();
            preloadPages();
            displayPage();
            adjustSpeed();
            if (!interval) previewEffect();
            localStorage.setItem('effect', effectSelect.value);
        });

        fontSize.addEventListener('input', () => {
            let value = Math.min(36, Math.max(12, fontSize.value));
            fontSize.value = value;
            textContent.style.fontSize = `${value}px`;
            pages = splitTextToFit(pages.join('\n\n'), textContent.getBoundingClientRect().height);
            preloadPages();
            displayPage();
            localStorage.setItem('fontSize', value);
        });

        fontFamily.addEventListener('change', () => {
            textContent.style.fontFamily = fontFamily.value;
            pages = splitTextToFit(pages.join('\n\n'), textContent.getBoundingClientRect().height);
            preloadPages();
            displayPage();
            localStorage.setItem('fontFamily', fontFamily.value);
        });

        lineHeight.addEventListener('change', () => {
            textContent.style.lineHeight = lineHeight.value;
            pages = splitTextToFit(pages.join('\n\n'), textContent.getBoundingClientRect().height);
            preloadPages();
            displayPage();
            localStorage.setItem('lineHeight', lineHeight.value);
        });

        letterSpacing.addEventListener('change', () => {
            textContent.style.letterSpacing = `${letterSpacing.value}px`;
            pages = splitTextToFit(pages.join('\n\n'), textContent.getBoundingClientRect().height);
            preloadPages();
            displayPage();
            localStorage.setItem('letterSpacing', letterSpacing.value);
        });

        autoRestart.addEventListener('change', () => localStorage.setItem('autoRestart', autoRestart.checked));
        pageAnimation.addEventListener('change', () => {
            localStorage.setItem('pageAnimation', pageAnimation.checked);
            displayPage();
        });
        showPageInfo.addEventListener('change', () => {
            localStorage.setItem('showPageInfo', showPageInfo.checked);
            displayPage();
        });
        fullscreenMode.addEventListener('change', () => localStorage.setItem('fullscreenMode', fullscreenMode.checked));
        marginTop.addEventListener('input', () => {
            updateTextContentMargins();
            pages = splitTextToFit(pages.join('\n\n'), textContent.getBoundingClientRect().height);
            preloadPages();
            displayPage();
            localStorage.setItem('marginTop', marginTop.value);
        });
        marginRight.addEventListener('input', () => {
            updateTextContentMargins();
            pages = splitTextToFit(pages.join('\n\n'), textContent.getBoundingClientRect().height);
            preloadPages();
            displayPage();
            localStorage.setItem('marginRight', marginRight.value);
        });
        marginBottom.addEventListener('input', () => {
            updateTextContentMargins();
            pages = splitTextToFit(pages.join('\n\n'), textContent.getBoundingClientRect().height);
            preloadPages();
            displayPage();
            localStorage.setItem('marginBottom', marginBottom.value);
        });
        marginLeft.addEventListener('input', () => {
            updateTextContentMargins();
            pages = splitTextToFit(pages.join('\n\n'), textContent.getBoundingClientRect().height);
            preloadPages();
            displayPage();
            localStorage.setItem('marginLeft', marginLeft.value);
        });

        prevPage.addEventListener('click', () => {
            if (currentPage > 0) {
                currentPage--;
                stopEffect();
                displayPage(-1);
            }
        });

        nextPage.addEventListener('click', () => {
            if (currentPage < pages.length - 1) {
                currentPage++;
                stopEffect();
                displayPage(1);
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' && currentPage > 0) {
                currentPage--;
                stopEffect();
                displayPage(-1);
            } else if (e.key === 'ArrowRight' && currentPage < pages.length - 1) {
                currentPage++;
                stopEffect();
                displayPage(1);
            }
        });

        const hammer = new Hammer(textContent, {
            threshold: 20,
            velocity: 0.3,
            inputClass: Hammer.TouchInput
        });
        hammer.get('swipe').set({ direction: Hammer.DIRECTION_HORIZONTAL });
        hammer.on('swipeleft', () => {
            console.log('Swipe left detected');
            if (currentPage < pages.length - 1) {
                currentPage++;
                stopEffect();
                displayPage(1);
            }
        });
        hammer.on('swiperight', () => {
            console.log('Swipe right detected');
            if (currentPage > 0) {
                currentPage--;
                stopEffect();
                displayPage(-1);
            }
        });

        resetSettings.addEventListener('click', () => {
            localStorage.clear();
            speedControl.value = 100;
            speedPreset.value = 100;
            effectSelect.value = 'char';
            fontSize.value = 18;
            fontFamily.value = 'Arial, sans-serif';
            lineHeight.value = 1.6;
            letterSpacing.value = 0;
            autoRestart.checked = false;
            pageAnimation.checked = true;
            showPageInfo.checked = true;
            fullscreenMode.checked = false;
            marginTop.value = 0;
            marginRight.value = 0;
            marginBottom.value = 0;
            marginLeft.value = 0;
            updateTextContentStyles();
            pages = splitTextToFit(pages.join('\n\n'), textContent.getBoundingClientRect().height);
            preloadPages();
            displayPage();
            message.innerText = '설정이 초기화되었습니다.';
            message.style.display = 'block';
            setTimeout(() => {
                message.style.display = 'none';
            }, 2000);
        });

        function updateTextContentStyles() {
            textContent.style.fontSize = `${fontSize.value}px`;
            textContent.style.fontFamily = fontFamily.value;
            textContent.style.lineHeight = lineHeight.value;
            textContent.style.letterSpacing = `${letterSpacing.value}px`;
            textContent.style.color = '#333';
            textContent.style.backgroundColor = '#fff';
            updateTextContentMargins();
        }

        function updateTextContentMargins() {
            textContent.style.marginTop = `${marginTop.value}vh`;
            textContent.style.marginRight = `${marginRight.value}vw`;
            textContent.style.marginBottom = `${marginBottom.value}vh`;
            textContent.style.marginLeft = `${marginLeft.value}vw`;
            textContent.style.width = `calc(100% - ${marginLeft.value}vw - ${marginRight.value}vw)`;
            textContent.style.height = `calc(70vh - ${marginTop.value}vh - ${marginBottom.value}vh - 80px)`;
        }

        function toggleButtons(disable) {
            startButton.disabled = disable;
            stopButton.disabled = disable;
            prevPage.disabled = disable;
            nextPage.disabled = disable;
        }

        function startEffect() {
            if (!textContent.innerText) {
                message.innerText = '먼저 파일을 업로드하세요.';
                message.style.display = 'block';
                return;
            }
            stopEffect();
            const effect = effectSelect.value;
            const intervalTime = parseInt(speedControl.value);
            const fadeStep = Math.min(0.05, 10 / intervalTime);

            if (effect === 'fade') {
                let opacity = 1;
                interval = setInterval(() => {
                    if (opacity > 0) {
                        opacity -= fadeStep;
                        textContent.style.opacity = opacity;
                    } else {
                        clearInterval(interval);
                        showCompletionMessage();
                    }
                }, intervalTime);
            } else if (effect === 'char') {
                const spans = textContent.querySelectorAll('.char-span:not(.char-space)');
                let charIndex = 0;
                const totalChars = spans.length;

                interval = setInterval(() => {
                    if (charIndex < spans.length) {
                        if (charIndex > 0) {
                            spans[charIndex - 1].classList.remove('current');
                        }
                        spans[charIndex].classList.add('current');
                        spans[charIndex].style.opacity = 0;
                        charIndex++;
                        const completedChars = Array.from(spans).filter(span => span.style.opacity === '0').length;
                        progress.value = (completedChars / totalChars) * 100;
                        progress.style.backgroundColor = `hsl(${progress.value * 1.2}, 70%, 50%)`;
                    } else {
                        if (charIndex > 0) {
                            spans[charIndex - 1].classList.remove('current');
                        }
                        const lines = textContent.querySelectorAll('.line');
                        lines.forEach(line => {
                            line.classList.add('hidden');
                            setTimeout(() => {
                                line.style.display = 'none';
                            }, 200);
                        });
                        clearInterval(interval);
                        showCompletionMessage();
                    }
                }, intervalTime / 2);
            } else if (effect === 'eink') {
                console.log('Starting e-ink mode');
                const spans = textContent.querySelectorAll('.char-span:not(.char-space)');
                let charIndex = 0;
                const totalChars = spans.length;

                interval = setInterval(() => {
                    if (charIndex < spans.length) {
                        if (charIndex > 0) {
                            spans[charIndex - 1].classList.remove('current');
                        }
                        spans[charIndex].classList.add('current');
                        spans[charIndex].style.color = '#000000';
                        charIndex++;
                        const completedChars = Array.from(spans).filter(span => span.style.color === 'rgb(0, 0, 0)').length;
                        progress.value = (completedChars / totalChars) * 100;
                        progress.style.backgroundColor = `hsl(${progress.value * 1.2}, 70%, 50%)`;
                        if (completedChars === totalChars) {
                            textContent.style.backgroundColor = '#000';
                            setTimeout(() => {
                                textContent.style.backgroundColor = '#fff';
                            }, 300);
                        }
                    } else {
                        if (charIndex > 0) {
                            spans[charIndex - 1].classList.remove('current');
                        }
                        const lines = textContent.querySelectorAll('.line');
                        lines.forEach(line => {
                            line.classList.add('hidden');
                            setTimeout(() => {
                                line.style.display = 'none';
                            }, 200);
                        });
                        clearInterval(interval);
                        showCompletionMessage();
                    }
                }, intervalTime / 2);
            }
        }

        function stopEffect() {
            if (interval) clearInterval(interval);
            textContent.style.opacity = 1;
            textContent.style.backgroundColor = '#fff';
            if (effectSelect.value === 'char' || effectSelect.value === 'eink') {
                textContent.querySelectorAll('.char-span').forEach(span => {
                    span.style.opacity = 1;
                    span.style.color = '#333';
                    span.classList.remove('current');
                });
                textContent.querySelectorAll('.line').forEach(line => {
                    line.classList.remove('hidden');
                    line.style.display = 'block';
                });
                progress.value = 0;
                progress.style.backgroundColor = '';
            }
        }

        function showCompletionMessage() {
            message.innerText = '훈련이 완료되었습니다!';
            message.style.color = 'green';
            message.style.display = 'block';
            setTimeout(() => {
                message.style.display = 'none';
            }, 2000);
        }

        function adjustSpeed() {
            if (interval) {
                stopEffect();
                startEffect();
            }
        }

        function previewEffect() {
            if (interval) return;
            const spans = textContent.querySelectorAll('.char-span:not(.char-space)');
            let index = 0;
            const preview = setInterval(() => {
                if (index < spans.length) {
                    if (effectSelect.value === 'char') {
                        spans[index].style.opacity = 0;
                    } else if (effectSelect.value === 'fade') {
                        spans[index].style.opacity = 0.5;
                    } else if (effectSelect.value === 'eink') {
                        spans[index].style.color = '#000000';
                    }
                    index++;
                } else {
                    clearInterval(preview);
                    spans.forEach(span => {
                        span.style.opacity = 1;
                        span.style.color = '#333';
                    });
                }
            }, speedControl.value);
        }
    </script>
</body>
</html>
