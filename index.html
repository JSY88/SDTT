<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>사라지는 텍스트 훈련</title>
    <style>
        :root {
            --font-size: 18px;
            --line-height: 1.6;
            --letter-spacing: 0px;
            --text-height: 70vh;
            --margin-top: 0vh;
            --margin-right: 0vw;
            --margin-bottom: 0vh;
            --margin-left: 0vw;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 5px;
            background-color: #f5f5f5;
            overscroll-behavior: none;
            position: relative;
            touch-action: pan-y;
            overflow-x: hidden;
        }

        #textContent {
            font-size: var(--font-size);
            line-height: var(--line-height);
            letter-spacing: var(--letter-spacing);
            white-space: pre-wrap;
            position: relative;
            overflow-y: hidden;
            overflow-x: hidden;
            width: calc(100% - var(--margin-left) - var(--margin-right));
            height: calc(var(--text-height) - var(--margin-top) - var(--margin-bottom) - 80px);
            margin-top: var(--margin-top);
            margin-right: var(--margin-right);
            margin-bottom: var(--margin-bottom);
            margin-left: var(--margin-left);
            padding: 10px;
            box-sizing: border-box;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            z-index: 1;
            color: #333;
            user-select: none;
            transition: opacity 0.3s;
        }

        #textContent.eink-mode {
            background-color: #000 !important;
            color: #000 !important;
        }

        #controls {
    margin: 10px 0;
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
    justify-content: center;
    align-items: center; /* 버튼 수평 정렬 */
}

        #message {
    color: red;
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(255, 255, 255, 0.95); /* 배경 투명도 약간 높임 */
    padding: 8px 15px; /* 패딩 약간 증가 */
    border-radius: 5px;
    z-index: 10;
    display: none;
    font-size: 16px; /* 글자 크기 증가 */
    font-weight: bold; /* 강조 */
}

        #retryButton {
            position: fixed;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 12px;
            font-size: 14px;
            border: none;
            border-radius: 5px;
            background-color: #e74c3c;
            color: white;
            cursor: pointer;
            display: none;
            z-index: 11;
        }

        #retryButton:hover {
            background-color: #c0392b;
        }

        #pageInfoContainer {
            position: fixed;
            top: 10px; /* 페이지 표시를 상단으로 이동 */
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 1000;
            display: none;
        }

        #pageInfo {
            font-size: 16px;
            background: transparent;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            border: none;
            color: #333;
            opacity: 0.5;
            transition: opacity 0.3s;
        }

        #pageInfo:hover {
            opacity: 0.8;
        }

        .speed-control {
            display: none; /* 기본적으로 숨김 */
            width: 50px;
            height: 50px;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 20px;
            color: #333;
            opacity: 0.5;
            transition: opacity 0.3s;
        }

        .paused .speed-control {
            display: block; /* 일시정지 시 표시 */
        }

        .speed-control:hover {
            opacity: 0.8;
        }

        #leftPageButton, #rightPageButton {
            display: none;
            position: fixed;
            top: 0;
            height: 100vh;
            width: 30vw;
            background: rgba(0, 0, 0, 0);
            border: none;
            z-index: 999;
            cursor: pointer;
            transition: none;
        }

        #leftPageButton:hover, #rightPageButton:hover,
        #leftPageButton:focus, #rightPageButton:focus,
        #leftPageButton:active, #rightPageButton:active {
            background: rgba(0, 0, 0, 0);
            transform: none;
            outline: none;
        }

        #leftPageButton {
            left: 0;
        }

        #rightPageButton {
            right: 0;
        }

        .fullscreen #leftPageButton, .fullscreen #rightPageButton {
            display: block;
        }

        #progressContainer {
            position: relative;
            width: 100%;
            margin: 5px 0;
        }

        #progress {
            width: 100%;
            height: 4px;
            opacity: 0.7;
            transition: none;
        }

        #progressPercent {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #333;
            display: none;
        }

        #loadingSpinner {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            z-index: 5;
        }

        button {
            padding: 8px 12px;
            font-size: 14px;
            border: none;
            border-radius: 5px;
            background-color: #3498db;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
            max-width: 100px;
        }

        button:hover {
            background-color: #2980b9;
            transform: scale(1.05);
        }

        button:focus {
            outline: 2px solid #2980b9;
            outline-offset: 2px;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        details {
            margin: 10px 0;
            width: 100%;
            z-index: 30;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        summary {
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }

        #advancedControls {
            padding: 15px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            align-items: center;
        }

        #advancedControls label {
            font-size: 14px;
            color: #333;
        }

        #advancedControls input[type="text"],
        #advancedControls input[type="range"],
        #advancedControls select,
        #advancedControls input[type="color"] {
            width: 100%;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }

        #advancedControls input[type="checkbox"] {
            margin-left: 5px;
        }

        #advancedControls button {
            max-width: none;
            width: 100%;
        }

        @keyframes charFade {
            to { opacity: 0; }
        }

        .char-span {
            transition: none;
        }

        .char-span.fade {
            animation: charFade 0.3s forwards;
        }

        .char-span.current {
            background-color: transparent;
        }

        .char-span.eink-black {
            background-color: #000 !important;
            color: #000 !important;
        }

        .line {
            display: block;
            transition: opacity 0.2s;
        }

        .line.hidden {
            opacity: 0;
        }

        .fullscreen #controls, .fullscreen #progressContainer, .fullscreen #message, .fullscreen #retryButton, .fullscreen details, .fullscreen #fileUpload {
            display: none;
        }

.fullscreen #textContent {
    width: 100vw;
    height: 100vh;
    margin: 0;
    padding: 40px 20px 20px 20px; /* 상단 패딩 증가로 더블탭 영역 확보 */
}

        .fullscreen #pageInfoContainer {
            display: flex;
        }

        #fileUpload {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            border: 2px dashed #3498db;
            border-radius: 5px;
            text-align: center;
            font-size: 16px;
            background-color: #f9f9f9;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #fileUpload:hover, #fileUpload.dragover {
            background-color: #e6f0fa;
        }

        #tocOverlay, #libraryOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 20;
            color: white;
            padding: 20px;
            overflow-y: auto;
        }

        #tocOverlay ul, #libraryOverlay ul {
            list-style: none;
            padding: 0;
        }

        #tocOverlay li, #libraryOverlay li {
            padding: 10px;
            cursor: pointer;
        }

        #tocOverlay li:hover, #libraryOverlay li:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        #libraryOverlay .library-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        #libraryOverlay .library-item img {
            width: 50px;
            height: 70px;
            object-fit: cover;
        }

        #libraryOverlay .library-item .no-cover {
            width: 50px;
            height: 70px;
            background: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 12px;
            color: #fff;
        }

        #libraryOverlay .library-item button {
            margin-left: 10px;
            padding: 2px 5px;
            font-size: 12px;
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        #libraryOverlay .library-item button:hover {
            background-color: #c0392b;
        }

        /* 페이지 이동 슬라이더 스타일 */
        #pageSliderContainer {
            display: none;
            position: fixed;
            bottom: 0;
            width: 100%;
            background: #fff;
            padding: 10px;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
            z-index: 1001;
        }

        #pageSlider {
            width: 100%;
        }

        /* 타이머 설정 UI 스타일 */
#timerSettings {
    display: none; /* 기본적으로 숨김 */
    position: fixed;
    bottom: 60px;
    width: 90%;
    max-width: 400px;
    left: 50%;
    transform: translateX(-50%);
    background: #fff;
    padding: 10px;
    box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
    z-index: 1002;
    text-align: center;
}

        #timerSettings input[type="number"] {
            width: 50px;
            padding: 5px;
            margin: 5px;
        }

        #timerSettings select {
            padding: 5px;
            margin: 5px;
        }

        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }

        @media (max-width: 600px) {
            body { padding: 5px; }
            #textContent {
                font-size: 16px;
                height: calc(var(--text-height) - 60px);
                padding: 8px;
            }
            #controls {
                flex-direction: column;
                gap: 3px;
            }
            button {
                padding: 8px 12px;
                font-size: 14px;
                max-width: 100%;
            }
            #advancedControls {
                grid-template-columns: 1fr;
                gap: 8px;
            }
            #pageInfo {
                font-size: 14px;
                padding: 6px 12px;
            }
            .speed-control {
                width: 40px;
                height: 40px;
                font-size: 18px;
            }
            #message {
                bottom: 60px;
                font-size: 14px;
            }
        }

        .black-mode body { background-color: #1a1a1a; }
        .black-mode #textContent { background-color: #2d2d2d; color: #fff; border-color: #444; }
        .black-mode summary { background-color: #3a3a3a; }
        .black-mode #fileUpload { background-color: #333; border-color: #555; }
        .black-mode #fileUpload:hover { background-color: #444; }
        .black-mode #pageInfo, .black-mode .speed-control { color: #fff; }

        #toggleButton {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 15;
        }

        .fullscreen #toggleButton {
            bottom: 10px;
            left: 10px;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nosleep.js@1.1.0/dist/NoSleep.min.js"></script>
</head>
<body>
    <input type="file" id="fileUpload" accept=".txt,.epub" aria-label="파일 업로드" multiple>
    <div id="controls" role="toolbar">
    <button id="toggleButton" aria-label="훈련 시작/중지">시작</button>
        <button id="prevPage" aria-label="이전 페이지"><span class="icon">◀</span> 이전</button>
        <button id="nextPage" aria-label="다음 페이지"><span class="icon">▶</span> 다음</button>
        <button id="tocButton" aria-label="목차">목차</button>
        <button id="libraryButton" aria-label="라이브러리">라이브러리</button>
        <input type="number" id="jumpToPage" min="1" placeholder="페이지로 이동" style="width: 100px; padding: 5px;">
    </div>
    <details>
        <summary>고급 설정</summary>
        <div id="advancedControls">
            <label for="speedControl">속도 (50ms ~ 2000ms):</label>
            <div><input type="range" id="speedControl" min="50" max="2000" step="1" value="100">
                 <input type="text" id="speedInput" value="100" style="width: 80px;"></div>
            <label for="speedPreset">속도 프리셋:</label>
            <select id="speedPreset">
                <option value="50">빠르게</option>
                <option value="100" selected>보통</option>
                <option value="200">느리게</option>
            </select>
            <label for="mobileSpeedControl">모바일 속도 조절:</label>
            <input type="checkbox" id="mobileSpeedControl">
            <label for="effectSelect">효과 선택:</label>
            <select id="effectSelect">
                <option value="char" selected>글자 단위 소멸</option>
                <option value="fade">페이드 아웃</option>
                <option value="eink">전자잉크 모드</option>
            </select>
            <label for="delayBeforeEffect">효과 시작 전 딜레이 (ms):</label>
            <div><input type="text" id="delayBeforeEffect" value="400"></div>
            <label for="fontSize">글꼴 크기:</label>
            <div><input type="text" id="fontSize" value="18">px</div>
            <label for="fontFamily">글꼴 스타일:</label>
            <select id="fontFamily">
                <option value="Arial, sans-serif">Arial</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="'Noto Sans KR', sans-serif">Noto Sans KR</option>
            </select>
            <label for="lineHeight">줄 간격:</label>
            <div><input type="text" id="lineHeight" value="1.6"></div>
            <label for="letterSpacing">글자 간격:</label>
            <div><input type="text" id="letterSpacing" value="0">px</div>
            <label for="preloadRange">프리로드 범위 (±페이지):</label>
            <div><input type="text" id="preloadRange" value="2"></div>
            <label for="textHeight">텍스트 영역 높이 (%):</label>
            <div><input type="text" id="textHeight" value="70"></div>
            <label for="pageInfoSize">페이지 표시 크기:</label>
            <div><input type="text" id="pageInfoSize" value="16">px</div>
            <label for="pageInfoOpacity">페이지 버튼 투명도 (0~1):</label>
            <div><input type="range" id="pageInfoOpacity" min="0" max="1" step="0.1" value="0.5"></div>
            <label for="autoRestart">페이지 전환 시 재시작:</label>
            <input type="checkbox" id="autoRestart">
            <label for="pageAnimation">페이지 전환 애니메이션:</label>
            <input type="checkbox" id="pageAnimation" checked>
            <label for="showPageInfo">페이지 번호 표시:</label>
            <input type="checkbox" id="showPageInfo" checked>
            <label for="fullscreenMode">전체 화면 모드:</label>
            <input type="checkbox" id="fullscreenMode">
            <label for="blackMode">블랙 모드:</label>
            <input type="checkbox" id="blackMode">
            <label for="blackModeColor">블랙 모드 색상:</label>
            <input type="color" id="blackModeColor" value="#2d2d2d">
            <label for="marginTop">위쪽 여백 (%):</label>
            <div><input type="text" id="marginTop" value="0"></div>
            <label for="marginRight">오른쪽 여백 (%):</label>
            <div><input type="text" id="marginRight" value="0"></div>
            <label for="marginBottom">아래쪽 여백 (%):</label>
            <div><input type="text" id="marginBottom" value="0"></div>
            <label for="marginLeft">왼쪽 여백 (%):</label>
            <div><input type="text" id="marginLeft" value="0"></div>
            <label for="enableFullScreenButtons">전체화면 버튼 활성화:</label>
            <input type="checkbox" id="enableFullScreenButtons" checked>
            <label for="fullScreenButtonWidth">전체화면 버튼 너비 (%):</label>
            <div><input type="text" id="fullScreenButtonWidth" value="30"></div>
            <label for="fullScreenButtonHeight">전체화면 버튼 높이 (%):</label>
            <div><input type="text" id="fullScreenButtonHeight" value="100"></div>
            <label for="autoPageTurn">글자 사라짐 후 자동 페이지 넘김:</label>
            <input type="checkbox" id="autoPageTurn" checked>
            <button id="resetSettings" aria-label="설정 초기화">설정 초기화</button>
            <button id="clearCacheButton" aria-label="캐시 비우기">캐시 비우기</button>
        </div>
    </details>
    <div id="progressContainer">
        <progress id="progress" value="0" max="100"></progress>
        <span id="progressPercent">0%</span>
    </div>
    <div id="textContent" role="region" aria-label="텍스트 표시 영역"></div>
    <div id="pageInfoContainer">
        <button id="speedDownButton" class="speed-control" aria-label="속도 감소">-</button>
        <button id="pageInfo" aria-live="polite"></button>
        <button id="speedUpButton" class="speed-control" aria-label="속도 증가">+</button>
    </div>
    <button id="leftPageButton" aria-label="이전 페이지로 이동"></button>
    <button id="rightPageButton" aria-label="다음 페이지로 이동"></button>
    <div id="loadingSpinner"></div>
    <div id="message" aria-live="assertive"></div>
    <button id="retryButton" aria-label="재시도">재시도</button>
    <div id="tocOverlay">
        <button id="closeToc" style="position: absolute; top: 10px; right: 10px; padding: 5px; background: #fff; border: none; cursor: pointer;">X</button>
        <div id="tocContent"></div>
    </div>
    <div id="libraryOverlay">
        <button id="closeLibrary" style="position: absolute; top: 10px; right: 10px; padding: 5px; background: #fff; border: none; cursor: pointer;">X</button>
        <div id="libraryContent"></div>
    </div>
    <!-- 페이지 이동 슬라이더 -->
    <div id="pageSliderContainer">
        <input type="range" id="pageSlider" min="0" max="0" value="0">
    </div>
    <!-- 타이머 설정 UI -->
    <div id="timerSettings">
        <label>세트 횟수: <input type="number" id="setCount" min="1" value="1"></label><br>
        <label>대기 시간: <input type="number" id="waitMin" min="0" value="0">분 <input type="number" id="waitSec" min="0" max="59" value="5">초</label><br>
        <label>읽기 시간: <input type="number" id="readMin" min="0" value="1">분 <input type="number" id="readSec" min="0" max="59" value="0">초</label><br>
        <label>일시정지: <input type="number" id="pauseMin" min="0" value="0">분 <input type="number" id="pauseSec" min="0" max="59" value="30">초</label><br>
        <label>휴식 시간: <input type="number" id="restMin" min="0" value="0">분 <input type="number" id="restSec" min="0" max="59" value="0">초</label><br>
        <label>읽기 알림음: <select id="readAlert">
            <option value="piano1">피아노 1</option>
            <option value="piano2">피아노 2</option>
            <option value="piano3">피아노 3</option>
        </select></label><br>
        <label>일시정지 알림음: <select id="pauseAlert">
            <option value="piano1">피아노 1</option>
            <option value="piano2">피아노 2</option>
            <option value="piano3">피아노 3</option>
        </select></label><br>
        <label>휴식 알림음: <select id="restAlert">
            <option value="piano1">피아노 1</option>
            <option value="piano2">피아노 2</option>
            <option value="piano3">피아노 3</option>
        </select></label><br>
        <label>종료 알림음: <select id="endAlert">
            <option value="piano1">피아노 1</option>
            <option value="piano2">피아노 2</option>
            <option value="piano3">피아노 3</option>
        </select></label><br>
        <button id="startTimer">타이머 시작</button>
        <button id="stopTimer">타이머 정지</button>
        <button id="saveConfig">구성 저장</button>
        <button id="loadConfig">구성 불러오기</button>
    </div>
    <!-- 알림음 오디오 요소 -->
<audio id="piano1" src="sounds/a.mp3" preload="auto"></audio>
<audio id="piano2" src="sounds/b.wav" preload="auto"></audio>
<audio id="piano3" src="sounds/c.wav" preload="auto"></audio>

    <script>
        let noSleep;

// script 최상단에 추가 (let interval 선언 근처)
let effectState = { type: null, index: 0, total: 0, isRunning: false };
let interval, pages = [], currentPage = 0, book, toc = [];
let worker, lastFileName = '';
let renderedPages = [];
let isFullscreen = false;
let libraryFiles = JSON.parse(localStorage.getItem('libraryFiles')) || [];
let isTrainingActive = false;
let messageTimer;
let lastSettings = {};
let isPaused = false;
let timerInterval, currentSet = 0, totalSets = 1;
let isPageTurning = false;
let isTimerRunning = false;
let isInitialLoad = true; // 첫 로드 여부 플래그 추가


        if (typeof NoSleep !== 'undefined') {
            noSleep = new NoSleep();
        } else {
            console.warn('NoSleep.js 로드 실패. 화면 잠금 방지 기능이 작동하지 않습니다.');
        }

        const fileInput = document.getElementById('fileUpload');
        const textContent = document.getElementById('textContent');
        const speedControl = document.getElementById('speedControl');
        const speedInput = document.getElementById('speedInput');
        const speedPreset = document.getElementById('speedPreset');
        const mobileSpeedControl = document.getElementById('mobileSpeedControl');
        const effectSelect = document.getElementById('effectSelect');
        const delayBeforeEffect = document.getElementById('delayBeforeEffect');
        const fontSize = document.getElementById('fontSize');
        const fontFamily = document.getElementById('fontFamily');
        const lineHeight = document.getElementById('lineHeight');
        const letterSpacing = document.getElementById('letterSpacing');
        const preloadRange = document.getElementById('preloadRange');
        const textHeight = document.getElementById('textHeight');
        const pageInfoSize = document.getElementById('pageInfoSize');
        const pageInfoOpacity = document.getElementById('pageInfoOpacity');
        const autoRestart = document.getElementById('autoRestart');
        const pageAnimation = document.getElementById('pageAnimation');
        const showPageInfo = document.getElementById('showPageInfo');
        const fullscreenMode = document.getElementById('fullscreenMode');
        const blackMode = document.getElementById('blackMode');
        const blackModeColor = document.getElementById('blackModeColor');
        const marginTop = document.getElementById('marginTop');
        const marginRight = document.getElementById('marginRight');
        const marginBottom = document.getElementById('marginBottom');
        const marginLeft = document.getElementById('marginLeft');
        const enableFullScreenButtons = document.getElementById('enableFullScreenButtons');
        const fullScreenButtonWidth = document.getElementById('fullScreenButtonWidth');
        const fullScreenButtonHeight = document.getElementById('fullScreenButtonHeight');
        const autoPageTurn = document.getElementById('autoPageTurn');
        const toggleButton = document.getElementById('toggleButton');
        const prevPage = document.getElementById('prevPage');
        const nextPage = document.getElementById('nextPage');
        const tocButton = document.getElementById('tocButton');
        const libraryButton = document.getElementById('libraryButton');
        const jumpToPage = document.getElementById('jumpToPage');
        const pageInfo = document.getElementById('pageInfo');
        const speedDownButton = document.getElementById('speedDownButton');
        const speedUpButton = document.getElementById('speedUpButton');
        const leftPageButton = document.getElementById('leftPageButton');
        const rightPageButton = document.getElementById('rightPageButton');
        const message = document.getElementById('message');
        const progress = document.getElementById('progress');
        const progressPercent = document.getElementById('progressPercent');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const retryButton = document.getElementById('retryButton');
        const resetSettings = document.getElementById('resetSettings');
        const tocOverlay = document.getElementById('tocOverlay');
        const tocContent = document.getElementById('tocContent');
        const libraryOverlay = document.getElementById('libraryOverlay');
        const libraryContent = document.getElementById('libraryContent');
        const clearCacheButton = document.getElementById('clearCacheButton');
        const pageSliderContainer = document.getElementById('pageSliderContainer');
        const pageSlider = document.getElementById('pageSlider');
        const timerSettings = document.getElementById('timerSettings');
        const setCount = document.getElementById('setCount');
        const waitMin = document.getElementById('waitMin');
        const waitSec = document.getElementById('waitSec');
        const readMin = document.getElementById('readMin');
        const readSec = document.getElementById('readSec');
        const pauseMin = document.getElementById('pauseMin');
        const pauseSec = document.getElementById('pauseSec');
        const restMin = document.getElementById('restMin');
        const restSec = document.getElementById('restSec');
        const startTimer = document.getElementById('startTimer');
        const stopTimer = document.getElementById('stopTimer');
        const saveConfig = document.getElementById('saveConfig');
        const loadConfig = document.getElementById('loadConfig');
        const readAlert = document.getElementById('readAlert');
        const pauseAlert = document.getElementById('pauseAlert');
        const restAlert = document.getElementById('restAlert');
        const endAlert = document.getElementById('endAlert');


        const DB_NAME = 'vanishingTextDB';
        const DB_VERSION = 1;
        const CACHE_STORE_NAME = 'fileCacheStore';
        let db;

        const dbPromise = new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onerror = (event) => {
                console.error('IndexedDB 초기화 오류:', event);
                reject(event);
            };
            request.onsuccess = (event) => {
                db = event.target.result;
                resolve();
            };
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(CACHE_STORE_NAME)) {
                    db.createObjectStore(CACHE_STORE_NAME);
                }
            };
        });

        async function getCachedData(fileName) {
    try {
        await dbPromise;
        return new Promise((resolve) => {
            if (!db) {
                console.warn('[IndexedDB] 데이터베이스 연결 없음');
                resolve(null);
                return;
            }
            const transaction = db.transaction([CACHE_STORE_NAME], 'readonly');
            const store = transaction.objectStore(CACHE_STORE_NAME);
            const request = store.get(fileName);
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => {
                console.error('[IndexedDB] 캐시 데이터 가져오기 실패:', fileName);
                resolve(null);
            };
        });
    } catch (err) {
        console.error('[IndexedDB] 캐시 데이터 접근 오류:', err);
        return null;
    }
}

        async function setCachedData(fileName, data) {
            await dbPromise.catch(() => {});
            return new Promise((resolve) => {
                if (!db) {
                    resolve();
                    return;
                }
                const transaction = db.transaction([CACHE_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(CACHE_STORE_NAME);
                const request = store.put(data, fileName);
                request.onsuccess = () => resolve();
                request.onerror = () => resolve();
            });
        }


function playAlert(soundId) {
    const audio = document.getElementById(soundId);
    console.log(`[알림음 재생 시도] ID: ${soundId}`);
    audio.play().then(() => {
        console.log(`[알림음 재생 성공] ${soundId}`);
    }).catch(err => {
        console.error(`[알림음 재생 오류] ${soundId}:`, err);
        showMessage(`알림음 재생 실패: ${soundId}`);
        // 폴백: 기본 알림음 재생
        const fallbackAudio = new Audio('https://www.soundjay.com/buttons/beep-01a.mp3');
        fallbackAudio.play().catch(fallbackErr => {
            console.error('[폴백 알림음 오류]:', fallbackErr);
        });
    });
}

        async function deleteCachedData(fileName) {
            await dbPromise.catch(() => {});
            return new Promise((resolve) => {
                if (!db) {
                    resolve();
                    return;
                }
                const transaction = db.transaction([CACHE_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(CACHE_STORE_NAME);
                const request = store.delete(fileName);
                request.onsuccess = () => resolve();
                request.onerror = () => resolve();
            });
        }

        async function clearIndexedDBCache() {
            await dbPromise.catch(() => {});
            return new Promise((resolve) => {
                if (!db) {
                    resolve();
                    return;
                }
                const transaction = db.transaction([CACHE_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(CACHE_STORE_NAME);
                const request = store.clear();
                request.onsuccess = () => resolve();
                request.onerror = () => resolve();
            });
        }

        async function pruneFileCache() {
            await dbPromise.catch(() => {});
            const MAX_CACHE_ENTRIES = 5;
            const cachedFiles = [];

            return new Promise((resolve) => {
                if (!db) {
                    resolve();
                    return;
                }
                const transaction = db.transaction([CACHE_STORE_NAME], 'readonly');
                const store = transaction.objectStore(CACHE_STORE_NAME);
                const request = store.openCursor();
                request.onsuccess = async function(event) {
                    const cursor = event.target.result;
                    if (cursor) {
                        const fileName = cursor.key;
                        const cacheEntry = cursor.value;
                        cachedFiles.push({ name: fileName, timestamp: cacheEntry.timestamp || Date.now() });
                        cursor.continue();
                    } else {
                        cachedFiles.sort((a, b) => a.timestamp - b.timestamp);
                        while (cachedFiles.length > MAX_CACHE_ENTRIES) {
                            const fileToRemove = cachedFiles.shift();
                            await deleteCachedData(fileToRemove.name);
                        }
                        resolve();
                    }
                };
                request.onerror = () => resolve();
            });
        }

        // 초기 설정 로드
        speedControl.value = localStorage.getItem('speed') || 100;
        speedInput.value = localStorage.getItem('speed') || 100;
        speedPreset.value = localStorage.getItem('speedPreset') || 100;
        mobileSpeedControl.checked = localStorage.getItem('mobileSpeedControl') === 'true';
        effectSelect.value = localStorage.getItem('effect') || 'char';
        delayBeforeEffect.value = localStorage.getItem('delayBeforeEffect') || 400;
        fontSize.value = localStorage.getItem('fontSize') || 18;
        fontFamily.value = localStorage.getItem('fontFamily') || 'Arial, sans-serif';
        lineHeight.value = localStorage.getItem('lineHeight') || 1.6;
        letterSpacing.value = localStorage.getItem('letterSpacing') || 0;
        preloadRange.value = localStorage.getItem('preloadRange') || 2;
        textHeight.value = localStorage.getItem('textHeight') || 70;
        pageInfoSize.value = localStorage.getItem('pageInfoSize') || 16;
        pageInfoOpacity.value = localStorage.getItem('pageInfoOpacity') || 0.5;
        autoRestart.checked = localStorage.getItem('autoRestart') === 'true';
        pageAnimation.checked = localStorage.getItem('pageAnimation') !== 'false';
        showPageInfo.checked = localStorage.getItem('showPageInfo') !== 'false';
        fullscreenMode.checked = localStorage.getItem('fullscreenMode') === 'true';
        blackMode.checked = localStorage.getItem('blackMode') === 'true';
        blackModeColor.value = localStorage.getItem('blackModeColor') || '#2d2d2d';
        marginTop.value = localStorage.getItem('marginTop') || 0;
        marginRight.value = localStorage.getItem('marginRight') || 0;
        marginBottom.value = localStorage.getItem('marginBottom') || 0;
        marginLeft.value = localStorage.getItem('marginLeft') || 0;
        enableFullScreenButtons.checked = localStorage.getItem('enableFullScreenButtons') !== 'false';
        fullScreenButtonWidth.value = localStorage.getItem('fullScreenButtonWidth') || 30;
        fullScreenButtonHeight.value = localStorage.getItem('fullScreenButtonHeight') || 100;
        autoPageTurn.checked = localStorage.getItem('autoPageTurn') !== 'false';
        updateTextContentStyles();
        toggleBlackMode();
        updateFullScreenButtons();
        updatePageInfoStyles();

        // 타이머 설정 초기값 로드
        const savedConfig = JSON.parse(localStorage.getItem('timerConfig'));
        if (savedConfig) {
            setCount.value = savedConfig.setCount || 1;
            waitMin.value = savedConfig.waitMin || 0;
            waitSec.value = savedConfig.waitSec || 5;
            readMin.value = savedConfig.readMin || 1;
            readSec.value = savedConfig.readSec || 0;
            pauseMin.value = savedConfig.pauseMin || 0;
            pauseSec.value = savedConfig.pauseSec || 30;
            restMin.value = savedConfig.restMin || 0;
            restSec.value = savedConfig.restSec || 0;
            readAlert.value = savedConfig.readAlert || 'piano1';
            pauseAlert.value = savedConfig.pauseAlert || 'piano2';
            restAlert.value = savedConfig.restAlert || 'piano3';
            endAlert.value = savedConfig.endAlert || 'piano1';
        }

        if (window.Worker) {
            const workerCode = `
                self.onmessage = function(e) {
                    const { text, maxHeight, fontSize, lineHeight, letterSpacing, fontFamily } = e.data;
                    const lines = text.split('\\n').filter(line => line.trim().length > 0);
                    const pages = [];
                    let currentPageText = '';
                    const lineHeightPx = parseFloat(lineHeight) * parseFloat(fontSize);
                    let currentHeight = 0;
                    for (let line of lines) {
                        currentHeight += lineHeightPx;
                        if (currentHeight > maxHeight) {
                            pages.push(currentPageText.trim());
                            currentPageText = line + '\\n';
                            currentHeight = lineHeightPx;
                        } else {
                            currentPageText += line + '\\n';
                        }
                    }
                    if (currentPageText.trim().length > 0) pages.push(currentPageText.trim());
                    self.postMessage({ pages });
                };
            `;
            worker = new Worker(URL.createObjectURL(new Blob([workerCode], { type: 'application/javascript' })));
        }

        function addToLibrary(fileName, fileData, coverUrl) {
            const existingIndex = libraryFiles.findIndex(item => item.name === fileName);
            if (existingIndex !== -1) {
                libraryFiles.splice(existingIndex, 1);
            }
            libraryFiles.unshift({ name: fileName, data: fileData, cover: coverUrl, timestamp: Date.now() });
            libraryFiles = libraryFiles.slice(0, 10);
            localStorage.setItem('libraryFiles', JSON.stringify(libraryFiles));
            pruneFileCache();
        }

        fileInput.addEventListener('change', function(event) {
            handleFileUpload(event.target.files[0]);
        });

        fileInput.addEventListener('dragover', (e) => {
            e.preventDefault();
            fileInput.classList.add('dragover');
        });

        fileInput.addEventListener('dragleave', () => {
            fileInput.classList.remove('dragover');
        });

        fileInput.addEventListener('drop', (e) => {
            e.preventDefault();
            fileInput.classList.remove('dragover');
            handleFileUpload(e.dataTransfer.files[0]);
        });

        function showMessage(text, duration = 3000) {
            console.log(`[메시지 표시] ${text}`);
            message.innerText = text;
            message.style.display = 'block';
            clearTimeout(messageTimer);
            messageTimer = setTimeout(() => {
                message.style.display = 'none';
            }, duration);
        }

        async function loadEpubLibraries() {
            if (!window.ePub || !window.JSZip) {
                showMessage('EPUB 라이브러리 로드 중...');
                const script1 = document.createElement('script');
                script1.src = 'https://unpkg.com/epubjs/dist/epub.min.js';
                const script2 = document.createElement('script');
                script2.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                document.head.appendChild(script1);
                document.head.appendChild(script2);
                await new Promise(resolve => {
                    script2.onload = resolve;
                });
            }
        }

        async function handleFileUpload(file) {
            await pruneFileCache();
            if (!file) {
                showMessage('파일을 선택해주세요.');
                loadingSpinner.style.display = 'none';
                return;
            }

            lastFileName = file.name;
            textContent.style.opacity = 1;
            showMessage('파일 로딩 중...');
            progress.value = 0;
            toggleButtons(true);
            loadingSpinner.style.display = 'block';
            retryButton.style.display = 'none';

            const reader = new FileReader();
            reader.onload = async function(event) {
                const fileData = event.target.result;
                let cachedData = await getCachedData(lastFileName);

                if (cachedData) {
                    pages = cachedData.pages;
                    toc = cachedData.toc || [];
                    loadLastPage();
                    preloadPages();
                    displayPage();
                    showMessage('');
                    progress.value = 0;
                    toggleButtons(false);
                    loadingSpinner.style.display = 'none';
                    addToLibrary(file.name, fileData, cachedData.coverUrl || null);
                    showMessage('단축키: 스페이스(시작/정지), ←/→(페이지 이동), +/- (속도 조절)', 5000);
                    return;
                }

                if (file.name.endsWith('.txt')) {
                    if (worker) {
                        worker.onmessage = async function(e) {
                            pages = e.data.pages;
                            await setCachedData(lastFileName, { pages: pages, timestamp: Date.now() });
                            loadLastPage();
                            preloadPages();
                            displayPage();
                            showMessage('');
                            progress.value = 0;
                            toggleButtons(false);
                            loadingSpinner.style.display = 'none';
                            addToLibrary(file.name, fileData, null);
                            showMessage('단축키: 스페이스(시작/정지), ←/→(페이지 이동), +/- (속도 조절)', 5000);
                        };
                        worker.onerror = function(e) {
                            showMessage('웹 워커 오류: ' + e.message);
                            toggleButtons(false);
                            loadingSpinner.style.display = 'none';
                            retryButton.style.display = 'block';
                        };
                        worker.postMessage({
                            text: fileData,
                            maxHeight: textContent.getBoundingClientRect().height,
                            fontSize: fontSize.value,
                            lineHeight: lineHeight.value,
                            letterSpacing: letterSpacing.value,
                            fontFamily: fontFamily.value
                        });
                    } else {
                        pages = splitTextToFit(fileData, textContent.getBoundingClientRect().height);
                        await setCachedData(lastFileName, { pages: pages, timestamp: Date.now() });
                        loadLastPage();
                        preloadPages();
                        displayPage();
                        showMessage('');
                        progress.value = 0;
                        toggleButtons(false);
                        loadingSpinner.style.display = 'none';
                        addToLibrary(file.name, fileData, null);
                        showMessage('단축키: 스페이스(시작/정지), ←/→(페이지 이동), +/- (속도 조절)', 5000);
                    }
                } else if (file.name.endsWith('.epub')) {
                    await loadEpubLibraries();
                    if (!window.ePub || !window.JSZip) {
                        showMessage('epub.js 또는 JSZip 로딩 실패.');
                        toggleButtons(false);
                        loadingSpinner.style.display = 'none';
                        retryButton.style.display = 'block';
                        return;
                    }
                    book = window.ePub(fileData);
                    try {
                        await book.ready;
                        showMessage('EPUB 파싱 중...');
                        const coverUrl = await book.coverUrl();
                        const pagesData = await loadEpubPages();
                        pages = pagesData;
                        const nav = await book.loaded.navigation;
                        toc = nav.toc;

                        await setCachedData(lastFileName, { pages: pages, toc: toc, coverUrl: coverUrl, timestamp: Date.now() });

                        loadLastPage();
                        preloadPages();
                        displayPage();
                        showMessage('');
                        progress.value = 0;
                        toggleButtons(false);
                        loadingSpinner.style.display = 'none';
                        addToLibrary(file.name, fileData, coverUrl);
                        showMessage('단축키: 스페이스(시작/정지), ←/→(페이지 이동), +/- (속도 조절)', 5000);
                    } catch (err) {
                        showMessage('EPUB 로드 오류: ' + err.message);
                        toggleButtons(false);
                        loadingSpinner.style.display = 'none';
                        retryButton.style.display = 'block';
                    }
                }
            };
            reader.onerror = function() {
                showMessage('파일 읽기 오류.');
                toggleButtons(false);
                loadingSpinner.style.display = 'none';
                retryButton.style.display = 'block';
            };
            if (file.name.endsWith('.txt')) {
                reader.readAsText(file, 'UTF-8');
            } else if (file.name.endsWith('.epub')) {
                reader.readAsArrayBuffer(file);
            }
        }

        async function loadEpubPages() {
            if (!book.rendition) {
                book.rendition = book.renderTo('textContent', {
                    ignoreContainerRead: true,
                    flow: 'paginated',
                    width: '100%',
                    height: '100%'
                });
            }
            let fullText = '';
            const sections = book.spine.items;
            for (let i = 0; i < sections.length; i++) {
                try {
                    const section = book.spine.get(i);
                    const content = await section.load(book.load.bind(book));
                    progress.value = (i / sections.length) * 50 + 50;
                    const text = content.innerText.trim();
                    if (text) fullText += text + '\n\n';
                    section.unload();
                } catch (e) {
                    console.warn(`Section ${i} 로드 실패, 건너뜁니다:`, e);
                    continue;
                }
            }
            return splitTextToFit(fullText, textContent.getBoundingClientRect().height);
        }

        function splitTextToFit(text, containerHeight) {
            const lines = text.split('\n').filter(line => line.trim().length > 0);
            const pages = [];
            let currentPageText = '';
            const testDiv = document.createElement('div');
            testDiv.style.cssText = `font-size: ${fontSize.value}px; line-height: ${lineHeight.value}; white-space: pre-wrap; visibility: hidden; position: absolute; padding: 10px; font-family: ${fontFamily.value}; letter-spacing: ${letterSpacing.value}px;`;
            document.body.appendChild(testDiv);
            for (let line of lines) {
                testDiv.innerText = currentPageText + line + '\n';
                if (testDiv.getBoundingClientRect().height > containerHeight) {
                    pages.push(currentPageText.trim());
                    currentPageText = line + '\n';
                } else {
                    currentPageText += line + '\n';
                }
            }
            if (currentPageText.trim().length > 0) pages.push(currentPageText.trim());
            document.body.removeChild(testDiv);
            return pages;
        }

        function preloadPages() {
            renderedPages = [];
            const range = Math.min(2, parseInt(preloadRange.value) || 2);
            const start = Math.max(0, currentPage - range);
            const end = Math.min(pages.length, currentPage + range + 1);
            for (let i = start; i < end; i++) {
                const text = pages[i];
                const lines = text.split('\n').filter(line => line.trim().length > 0);
                const html = lines.map(line => {
                    const chars = line.split('');
                    return `<div class="line">${chars.map(char => char.trim() === '' ? `<span class="char-span char-space">${char}</span>` : `<span class="char-span">${char}</span>`).join('')}</div>`;
                }).join('');
                renderedPages[i] = html;
            }
            Object.keys(renderedPages).forEach(key => {
                const pageNum = parseInt(key);
                if (pageNum < start || pageNum >= end) {
                    delete renderedPages[pageNum];
                }
            });
        }

        function displayPage(direction = 0) {
    console.log(`[페이지 표시] 현재 페이지: ${currentPage + 1}/${pages.length}, 초기 로드 여부: ${isInitialLoad}, 일시정지 여부: ${isPaused}`);
    const fragment = document.createDocumentFragment();
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = renderedPages[currentPage] || '';
    while (tempDiv.firstChild) fragment.appendChild(tempDiv.firstChild);
    textContent.innerHTML = '';
    textContent.appendChild(fragment);

    pageInfo.innerText = (showPageInfo.checked || isFullscreen) ? `${currentPage + 1}/${pages.length}` : '';
    pageInfo.style.fontSize = `${pageInfoSize.value}px`;
    updatePageInfoStyles();
    progress.value = 0;
    updateProgressPercent(0);

    // 페이지 전환 애니메이션 처리
    if (pageAnimation.checked && direction !== 0) {
        textContent.style.transform = direction > 0 ? 'translateX(-100%)' : 'translateX(100%)';
        textContent.style.opacity = 0;
        setTimeout(() => {
            textContent.style.transform = 'translateX(0)';
            textContent.style.opacity = 1;
            if (!isInitialLoad) {
                console.log('[페이지 전환 후 효과 시작] 애니메이션 완료 후 호출');
                startEffect(); // 페이지 전환 시 항상 효과 시작
            }
            isPageTurning = false; // 페이지 전환 완료
            console.log('[페이지 전환 완료] 플래그 해제');
        }, 300);
    } else if (!isInitialLoad) {
        console.log('[페이지 전환 후 효과 시작] 즉시 호출');
        startEffect(); // 초기 로드가 아니면 즉시 효과 시작
        isPageTurning = false; // 페이지 전환 완료
        console.log('[페이지 전환 완료] 플래그 해제');
    }
    preloadPages();
    saveLastPage();
    updatePageSlider();
}





        function loadLastPage() {
            const lastPage = localStorage.getItem(`lastPage_${lastFileName}`);
            currentPage = lastPage ? parseInt(lastPage) : 0;
            currentPage = Math.max(0, Math.min(currentPage, pages.length - 1));
        }

        function saveLastPage() {
            localStorage.setItem(`lastPage_${lastFileName}`, currentPage);
        }

        toggleButton.addEventListener('click', () => {
            console.log(`[토글 버튼 클릭] 훈련 상태: ${isTrainingActive ? '정지' : '시작'}`);
            if (!isTrainingActive) {
                if (fullscreenMode.checked) {
                    const requestFullscreen = document.documentElement.requestFullscreen || document.documentElement.webkitRequestFullscreen;
                    if (!document.fullscreenElement && requestFullscreen) {
                        requestFullscreen.call(document.documentElement).then(() => {
                            document.body.style.opacity = 0;
                            setTimeout(() => {
                                document.body.classList.add('fullscreen');
                                document.body.style.opacity = 1;
                                if (noSleep) noSleep.enable();
                                isFullscreen = true;
                                updateFullScreenButtons();
                            }, 300);
                        }).catch(() => {
                            showMessage('전체화면 모드 활성화 실패.');
                        });
                    }
                }
                startEffect();
                toggleButton.innerText = '정지';
                isTrainingActive = true;
            } else {
                stopEffect();
                exitFullscreen();
                toggleButton.innerText = '시작';
                isTrainingActive = false;
            }
        });

function startEffect() {
    if (interval) {
        clearInterval(interval);
        console.log('[효과 시작] 기존 interval 정리 완료');
    }
    console.log(`[효과 시작] 효과: ${effectSelect.value}, 속도: ${speedControl.value}ms`);
    effectState.type = effectSelect.value;
    effectState.isRunning = true;
    effectState.index = effectState.index || 0; // 재개 시 이전 인덱스 유지

    const delay = parseInt(delayBeforeEffect.value);
    setTimeout(() => {
        if (effectState.type === 'char') {
            const spans = textContent.querySelectorAll('.char-span:not(.char-space)');
            effectState.total = spans.length;
            const intervalTime = parseInt(speedControl.value) / 2;
            interval = setInterval(() => {
                if (effectState.index < effectState.total && effectState.isRunning) {
                    spans[effectState.index].classList.add('fade');
                    effectState.index++;
                    progress.value = (effectState.index / effectState.total) * 100;
                    updateProgressPercent(progress.value);
                } else if (effectState.index >= effectState.total) {
                    clearInterval(interval);
                    effectState.isRunning = false;
                    console.log('[효과 종료] 모든 글자 사라짐 완료');
                    if (autoPageTurn.checked && currentPage < pages.length - 1 && !isPageTurning) {
                        isPageTurning = true;
                        console.log('[자동 페이지 넘김] 시작 - 플래그 설정');
                        nextPage.click();
                    }
                }
            }, intervalTime);
        } else if (effectState.type === 'fade') {
            const lines = textContent.querySelectorAll('.line');
            effectState.total = lines.length;
            const intervalTime = parseInt(speedControl.value);
            interval = setInterval(() => {
                if (effectState.index < effectState.total && effectState.isRunning) {
                    lines[effectState.index].classList.add('hidden');
                    effectState.index++;
                    progress.value = (effectState.index / effectState.total) * 100;
                    updateProgressPercent(progress.value);
                } else if (effectState.index >= effectState.total) {
                    clearInterval(interval);
                    effectState.isRunning = false;
                    console.log('[효과 종료] 모든 라인 페이드 완료');
                    if (autoPageTurn.checked && currentPage < pages.length - 1 && !isPageTurning) {
                        isPageTurning = true;
                        console.log('[자동 페이지 넘김] 시작 - 플래그 설정');
                        nextPage.click();
                    }
                }
            }, intervalTime);
        } else if (effectState.type === 'eink') {
            const spans = textContent.querySelectorAll('.char-span:not(.char-space)');
            effectState.total = spans.length;
            const intervalTime = parseInt(speedControl.value) / 2;
            textContent.classList.add('eink-mode');
            interval = setInterval(() => {
                if (effectState.index < effectState.total && effectState.isRunning) {
                    spans[effectState.index].classList.add('eink-black');
                    effectState.index++;
                    progress.value = (effectState.index / effectState.total) * 100;
                    updateProgressPercent(progress.value);
                } else if (effectState.index >= effectState.total) {
                    clearInterval(interval);
                    effectState.isRunning = false;
                    console.log('[효과 종료] 전자잉크 효과 완료');
                    if (autoPageTurn.checked && currentPage < pages.length - 1 && !isPageTurning) {
                        isPageTurning = true;
                        console.log('[자동 페이지 넘김] 시작 - 플래그 설정');
                        nextPage.click();
                    }
                }
            }, intervalTime);
        }
    }, delay);
}







function stopEffect() {
    if (interval) {
        clearInterval(interval);
        interval = null;
    }
    effectState.isRunning = false;
    effectState.index = 0; // 효과 완전 정지 시 초기화
    console.log('[효과 정지] 완전 정지 및 상태 초기화');
}



        function exitFullscreen() {
            const exitFullscreen = document.exitFullscreen || document.webkitExitFullscreen;
            if (document.fullscreenElement && exitFullscreen) {
                document.body.style.opacity = 0;
                setTimeout(() => {
                    exitFullscreen.call(document).then(() => {
                        document.body.classList.remove('fullscreen');
                        document.body.style.opacity = 1;
                        if (noSleep) noSleep.disable();
                        isFullscreen = false;
                        updateFullScreenButtons();
                    }).catch(() => {
                        showMessage('전체화면 모드 종료 실패.');
                    });
                }, 300);
            }
        }

        // 더블탭 이벤트 처리
        const hammer = new Hammer(textContent);
        hammer.on('doubletap', function() {
            console.log(`[더블탭] 일시정지 상태: ${isPaused ? '해제' : '활성화'}`);
            if (isPaused) {
                resumeEffect();
            } else {
                pauseEffect();
            }
        });

        function pauseEffect() {
    if (interval) {
        clearInterval(interval);
        interval = null;
    }
    effectState.isRunning = false;
    isPaused = true;
    document.body.classList.add('paused');
    pageSliderContainer.style.display = 'block';
    timerSettings.style.display = 'block';
    updatePageSlider();
    showMessage('일시정지됨');
    console.log('[일시정지] 효과 정지 및 UI 표시 - 현재 인덱스:', effectState.index);
}

        function resumeEffect() {
    isPaused = false;
    document.body.classList.remove('paused');
    pageSliderContainer.style.display = 'none';
    timerSettings.style.display = 'none';
    showMessage('재개됨');
    console.log('[재개] 효과 재시작 - 현재 인덱스:', effectState.index);
    if (effectState.type && effectState.index < effectState.total) {
        startEffect(); // 저장된 상태에서 효과 이어감
    }
}

        function updatePageSlider() {
            pageSlider.max = pages.length - 1;
            pageSlider.value = currentPage;
        }

        pageSlider.addEventListener('input', function() {
            currentPage = parseInt(this.value);
            stopEffect();
            displayPage();
            console.log(`[슬라이더 이동] 페이지: ${currentPage + 1}`);
        });

        pageInfo.addEventListener('click', () => {
            stopEffect();
            exitFullscreen();
        });

        speedDownButton.addEventListener('click', () => {
    let newSpeed = Math.max(50, parseInt(speedControl.value) - 5);
    speedControl.value = newSpeed;
    speedInput.value = newSpeed;
    speedPreset.value = newSpeed;
    adjustSpeed();
    localStorage.setItem('speed', newSpeed);
    showMessage(`현재 속도: ${newSpeed}ms`, 1500); // 지속 시간 1500ms로 조정
    console.log(`[속도 감소] 새로운 속도: ${newSpeed}ms, 메시지 표시됨`);
});

speedUpButton.addEventListener('click', () => {
    let newSpeed = Math.min(2000, parseInt(speedControl.value) + 5);
    speedControl.value = newSpeed;
    speedInput.value = newSpeed;
    speedPreset.value = newSpeed;
    adjustSpeed();
    localStorage.setItem('speed', newSpeed);
    showMessage(`현재 속도: ${newSpeed}ms`, 1500); // 지속 시간 1500ms로 조정
    console.log(`[속도 증가] 새로운 속도: ${newSpeed}ms, 메시지 표시됨`);
});

        leftPageButton.addEventListener('pointerdown', () => {
            if (currentPage > 0) {
                currentPage--;
                stopEffect();
                displayPage(-1);
            }
        });

        rightPageButton.addEventListener('pointerdown', () => {
            if (currentPage < pages.length - 1) {
                currentPage++;
                stopEffect();
                displayPage(1);
            }
        });

        tocButton.addEventListener('click', showToc);

        libraryButton.addEventListener('click', () => {
            libraryContent.innerHTML = '<ul>' + libraryFiles.sort((a, b) => b.timestamp - a.timestamp).map((file, index) => {
                const cover = file.cover ? `<img src="${file.cover}" alt="${file.name} 표지">` : `<div class="no-cover">${file.name}</div>`;
                return `<li class="library-item" data-index="${index}">${cover}<span>${file.name}</span><button class="delete-button" data-index="${index}">삭제</button></li>`;
            }).join('') + '</ul>';
            libraryOverlay.style.display = 'block';

            libraryContent.querySelectorAll('li').forEach(li => {
                li.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const index = parseInt(li.dataset.index);
                    const file = libraryFiles[index];
                    lastFileName = file.name;
                    libraryOverlay.style.display = 'none';
                    showMessage('라이브러리에서 불러오는 중...');
                    toggleButtons(true);
                    loadingSpinner.style.display = 'block';

                    await pruneFileCache();

                    let cachedData = await getCachedData(lastFileName);
                    if (cachedData) {
                        pages = cachedData.pages;
                        toc = cachedData.toc || [];
                        loadLastPage();
                        preloadPages();
                        displayPage();
                        showMessage('');
                        toggleButtons(false);
                        loadingSpinner.style.display = 'none';
                        return;
                    }

                    if (file.name.endsWith('.txt')) {
                        pages = splitTextToFit(file.data, textContent.getBoundingClientRect().height);
                        await setCachedData(lastFileName, { pages: pages, timestamp: Date.now() });
                        loadLastPage();
                        preloadPages();
                        displayPage();
                    } else if (file.name.endsWith('.epub')) {
                        await loadEpubLibraries();
                        book = window.ePub(file.data);
                        try {
                            await book.ready;
                            const pagesData = await loadEpubPages();
                            pages = pagesData;
                            const nav = await book.loaded.navigation;
                            toc = nav.toc;
                            await setCachedData(lastFileName, { pages: pages, toc: toc, timestamp: Date.now() });
                            loadLastPage();
                            preloadPages();
                            displayPage();
                        } catch (err) {
                            showMessage('EPUB 로드 오류: ' + err.message);
                            toggleButtons(false);
                            loadingSpinner.style.display = 'none';
                            retryButton.style.display = 'block';
                            return;
                        }
                    }
                    showMessage('');
                    toggleButtons(false);
                    loadingSpinner.style.display = 'none';
                });

                const deleteButton = li.querySelector('.delete-button');
                deleteButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const index = parseInt(deleteButton.dataset.index);
                    libraryFiles.splice(index, 1);
                    localStorage.setItem('libraryFiles', JSON.stringify(libraryFiles));
                    libraryButton.click();
                    showMessage('파일이 삭제되었습니다.', 2000);
                });
            });

            document.getElementById('closeLibrary').addEventListener('click', () => {
                libraryOverlay.style.display = 'none';
            });
        });

        // 타이머 이벤트 리스너
startTimer.addEventListener('click', function() {
    if (isTimerRunning) {
        console.log('[타이머 시작 요청] 이미 실행 중 - 무시');
        showMessage('타이머가 이미 실행 중입니다.', 2000);
        return;
    }
    console.log('[타이머 시작 요청] 시작 준비');
    totalSets = parseInt(setCount.value);
    const waitTime = (parseInt(waitMin.value) * 60 + parseInt(waitSec.value)) * 1000;
    const readTime = (parseInt(readMin.value) * 60 + parseInt(readSec.value)) * 1000;
    const pauseTime = (parseInt(pauseMin.value) * 60 + parseInt(pauseSec.value)) * 1000;
    const restTime = (parseInt(restMin.value) * 60 + parseInt(restSec.value)) * 1000;
    currentSet = 0;

    if (!isTrainingActive) toggleButton.click();
    if (isPaused) {
        console.log('[타이머 시작] 일시정지 상태 감지, 해제 및 전체화면 복귀');
        resumeEffect(); // 일시정지 해제 및 UI 숨김
    }
    if (fullscreenMode.checked && !isFullscreen) {
        const requestFullscreen = document.documentElement.requestFullscreen || document.documentElement.webkitRequestFullscreen;
        requestFullscreen.call(document.documentElement).then(() => {
            document.body.classList.add('fullscreen');
            isFullscreen = true;
            updateFullScreenButtons();
            console.log('[타이머 시작] 전체화면 모드 활성화');
        }).catch(err => {
            console.error('[전체화면 오류]', err);
            showMessage('전체화면 모드 활성화 실패.');
        });
    }
    isTimerRunning = true; // 타이머 시작 플래그 설정
    showMessage(`대기 시간 ${waitTime / 1000}초 후 읽기 시작`, waitTime);
    console.log(`[타이머 시작] 대기 시간 ${waitTime}ms 설정`);
    if (timerInterval) clearTimeout(timerInterval); // 기존 타이머 초기화
    timerInterval = setTimeout(() => {
        console.log('[타이머 시작] 대기 후 읽기 타이머 시작');
        playAlert(readAlert.value);
        startReadTimer(readTime, pauseTime, restTime);
    }, waitTime);
});


        loadConfig.addEventListener('click', function() {
            const savedConfig = JSON.parse(localStorage.getItem('timerConfig'));
            if (savedConfig) {
                setCount.value = savedConfig.setCount;
                waitMin.value = savedConfig.waitMin;
                waitSec.value = savedConfig.waitSec;
                readMin.value = savedConfig.readMin;
                readSec.value = savedConfig.readSec;
                pauseMin.value = savedConfig.pauseMin;
                pauseSec.value = savedConfig.pauseSec;
                restMin.value = savedConfig.restMin;
                restSec.value = savedConfig.restSec;
                readAlert.value = savedConfig.readAlert;
                pauseAlert.value = savedConfig.pauseAlert;
                restAlert.value = savedConfig.restAlert;
                endAlert.value = savedConfig.endAlert;
                showMessage('구성이 불러와졌습니다.');
                console.log('[구성 불러오기]', savedConfig);
            } else {
                showMessage('저장된 구성이 없습니다.');
            }
        });

function startReadTimer(readTime, pauseTime, restTime) {
    // 모든 세트가 완료되었는지 확인
    if (currentSet >= totalSets) {
        playAlert(endAlert.value); // 종료 알림음 재생
        showMessage('모든 세트가 완료되었습니다.');
        console.log('[타이머 종료] 모든 세트 완료');
        stopEffect(); // 효과 완전히 정지
        isTimerRunning = false; // 타이머 종료 플래그 설정
        if (timerInterval) clearTimeout(timerInterval); // 기존 타이머 정리
        pauseEffect(); // 일시정지 상태로 전환하여 사용자 재개 가능
        console.log('[타이머 종료 후 일시정지] 효과 일시정지 상태로 전환');
        return;
    }

    currentSet++; // 다음 세트로 이동
    startEffect(); // 읽기 시간 동안 효과 시작
    showMessage(`세트 ${currentSet}/${totalSets} 시작: 읽는 시간 ${readTime / 1000}초`);
    console.log(`[읽기 시작] 세트 ${currentSet}/${totalSets}`);

    if (timerInterval) clearTimeout(timerInterval); // 이전 타이머 초기화
    timerInterval = setTimeout(() => {
        console.log(`[읽기 종료] 세트 ${currentSet} - 일시정지로 전환`);
        pauseEffect(); // 효과 유지하며 일시정지
        playAlert(pauseAlert.value); // 일시정지 알림음
        showMessage(`세트 ${currentSet}/${totalSets} 일시정지: ${pauseTime / 1000}초`);
        console.log(`[일시정지 시작] 세트 ${currentSet}`);

        timerInterval = setTimeout(() => {
            resumeEffect(); // 일시정지 해제
            if (restTime > 0 && currentSet < totalSets) {
                stopEffect(); // 휴식 전 효과 초기화
                playAlert(restAlert.value); // 휴식 알림음
                showMessage(`세트 ${currentSet}/${totalSets} 휴식: ${restTime / 1000}초`);
                console.log(`[휴식 시작] 세트 ${currentSet}`);
                timerInterval = setTimeout(() => {
                    console.log(`[휴식 종료] 세트 ${currentSet} - 다음 읽기 시작`);
                    startReadTimer(readTime, pauseTime, restTime); // 다음 세트 시작
                }, restTime);
            } else {
                console.log(`[일시정지 종료] 세트 ${currentSet} - 다음 읽기 시작`);
                startReadTimer(readTime, pauseTime, restTime); // 즉시 다음 세트 시작
            }
        }, pauseTime);
    }, readTime);
}
stopTimer.addEventListener('click', function() {
    if (timerInterval) {
        clearTimeout(timerInterval);
        timerInterval = null;
    }
    stopEffect();
    isTimerRunning = false; // 타이머 중지 시 플래그 해제
    showMessage('타이머가 정지되었습니다.', 2000);
    console.log('[타이머 정지] 타이머 및 효과 정리 완료');
});


        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        speedControl.addEventListener('input', () => {
            speedInput.value = speedControl.value;
            speedPreset.value = speedControl.value;
            adjustSpeed();
            if (!interval) previewEffect();
            localStorage.setItem('speed', speedControl.value);
        });

        speedInput.addEventListener('input', () => {
            speedControl.value = speedInput.value;
            speedPreset.value = speedInput.value;
            adjustSpeed();
            if (!interval) previewEffect();
            localStorage.setItem('speed', speedInput.value);
        });

        speedPreset.addEventListener('change', () => {
            speedControl.value = speedPreset.value;
            speedInput.value = speedPreset.value;
            adjustSpeed();
            if (!interval) previewEffect();
            localStorage.setItem('speedPreset', speedPreset.value);
        });

        mobileSpeedControl.addEventListener('change', () => {
            localStorage.setItem('mobileSpeedControl', mobileSpeedControl.checked);
        });

        effectSelect.addEventListener('change', () => {
            stopEffect();
            preloadPages();
            displayPage();
            adjustSpeed();
            if (!interval) previewEffect();
            localStorage.setItem('effect', effectSelect.value);
        });

        delayBeforeEffect.addEventListener('input', () => {
            localStorage.setItem('delayBeforeEffect', delayBeforeEffect.value);
        });

        const debouncedUpdateStyles = debounce(() => {
            updateTextContentStyles();
            pages = splitTextToFit(pages.join('\n\n'), textContent.getBoundingClientRect().height);
            preloadPages();
            displayPage();
        }, 300);

        fontSize.addEventListener('input', () => {
            localStorage.setItem('fontSize', fontSize.value);
            debouncedUpdateStyles();
        });

        fontFamily.addEventListener('change', () => {
            localStorage.setItem('fontFamily', fontFamily.value);
            debouncedUpdateStyles();
        });

        lineHeight.addEventListener('input', () => {
            localStorage.setItem('lineHeight', lineHeight.value);
            debouncedUpdateStyles();
        });

        letterSpacing.addEventListener('input', () => {
            localStorage.setItem('letterSpacing', letterSpacing.value);
            debouncedUpdateStyles();
        });

        preloadRange.addEventListener('input', () => {
            preloadPages();
            displayPage();
            localStorage.setItem('preloadRange', preloadRange.value);
        });

        textHeight.addEventListener('input', () => {
            localStorage.setItem('textHeight', textHeight.value);
            debouncedUpdateStyles();
        });

        pageInfoSize.addEventListener('input', () => {
            pageInfo.style.fontSize = `${pageInfoSize.value}px`;
            speedDownButton.style.fontSize = `${pageInfoSize.value}px`;
            speedUpButton.style.fontSize = `${pageInfoSize.value}px`;
            localStorage.setItem('pageInfoSize', pageInfoSize.value);
            displayPage();
        });

        pageInfoOpacity.addEventListener('input', () => {
            localStorage.setItem('pageInfoOpacity', pageInfoOpacity.value);
            updatePageInfoStyles();
        });

        autoRestart.addEventListener('change', () => localStorage.setItem('autoRestart', autoRestart.checked));
        pageAnimation.addEventListener('change', () => {
            localStorage.setItem('pageAnimation', pageAnimation.checked);
            displayPage();
        });
        showPageInfo.addEventListener('change', () => {
            localStorage.setItem('showPageInfo', showPageInfo.checked);
            displayPage();
        });
        fullscreenMode.addEventListener('change', () => localStorage.setItem('fullscreenMode', fullscreenMode.checked));
        blackMode.addEventListener('change', () => {
            localStorage.setItem('blackMode', blackMode.checked);
            toggleBlackMode();
        });
        blackModeColor.addEventListener('input', () => {
            localStorage.setItem('blackModeColor', blackModeColor.value);
            toggleBlackMode();
        });

        marginTop.addEventListener('input', () => {
            localStorage.setItem('marginTop', marginTop.value);
            debouncedUpdateStyles();
        });
        marginRight.addEventListener('input', () => {
            localStorage.setItem('marginRight', marginRight.value);
            debouncedUpdateStyles();
        });
        marginBottom.addEventListener('input', () => {
            localStorage.setItem('marginBottom', marginBottom.value);
            debouncedUpdateStyles();
        });
        marginLeft.addEventListener('input', () => {
            localStorage.setItem('marginLeft', marginLeft.value);
            debouncedUpdateStyles();
        });
        enableFullScreenButtons.addEventListener('change', () => {
            localStorage.setItem('enableFullScreenButtons', enableFullScreenButtons.checked);
            updateFullScreenButtons();
        });
        fullScreenButtonWidth.addEventListener('input', () => {
            localStorage.setItem('fullScreenButtonWidth', fullScreenButtonWidth.value);
            updateFullScreenButtons();
        });
        fullScreenButtonHeight.addEventListener('input', () => {
            localStorage.setItem('fullScreenButtonHeight', fullScreenButtonHeight.value);
            updateFullScreenButtons();
        });
        autoPageTurn.addEventListener('change', () => {
            localStorage.setItem('autoPageTurn', autoPageTurn.checked);
        });

        prevPage.addEventListener('click', () => {
            if (currentPage > 0) {
                currentPage--;
                stopEffect();
                displayPage(-1);
            }
        });

        nextPage.addEventListener('click', () => {
            if (currentPage < pages.length - 1) {
                currentPage++;
                stopEffect();
                displayPage(1);
            }
        });

        jumpToPage.addEventListener('change', () => {
            let pageNum = parseInt(jumpToPage.value) - 1;
            if (pageNum >= 0 && pageNum < pages.length) {
                currentPage = pageNum;
                stopEffect();
                displayPage();
            }
            jumpToPage.value = '';
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' && currentPage > 0) {
                currentPage--;
                stopEffect();
                displayPage(-1);
            } else if (e.key === 'ArrowRight' && currentPage < pages.length - 1) {
                currentPage++;
                stopEffect();
                displayPage(1);
            } else if (e.key === ' ' || e.key === 'Spacebar') {
                e.preventDefault();
                toggleButton.click();
            } else if (e.key === 'Enter') {
                if (currentPage < pages.length - 1) {
                    currentPage++;
                    stopEffect();
                    displayPage(1);
                }
            } else if (e.key === '+') {
                let newSpeed = Math.min(2000, parseInt(speedControl.value) + 5);
                speedControl.value = newSpeed;
                speedInput.value = newSpeed;
                speedPreset.value = newSpeed;
                adjustSpeed();
                localStorage.setItem('speed', newSpeed);
            } else if (e.key === '-') {
                let newSpeed = Math.max(50, parseInt(speedControl.value) - 5);
                speedControl.value = newSpeed;
                speedInput.value = newSpeed;
                speedPreset.value = newSpeed;
                adjustSpeed();
                localStorage.setItem('speed', newSpeed);
            } else if (e.key === 'Home') {
                currentPage = 0;
                stopEffect();
                displayPage();
            } else if (e.key === 'End') {
                currentPage = pages.length - 1;
                stopEffect();
                displayPage();
            } else if (e.key === 'Escape' && (tocOverlay.style.display === 'block' || libraryOverlay.style.display === 'block')) {
                tocOverlay.style.display = 'none';
                libraryOverlay.style.display = 'none';
            }
        });

        let touchStartX = 0;
        let lastTouchTime = 0;
        textContent.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            lastTouchTime = Date.now();
        });

        textContent.addEventListener('touchend', (e) => {
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const deltaX = touchEndX - touchStartX;
            const timeDiff = Date.now() - lastTouchTime;

            if (timeDiff > 300) { // 디바운싱: 300ms 이상 간격
                if (mobileSpeedControl.checked && touchEndY > window.innerHeight * 0.8) {
                    if (touchEndX > window.innerWidth * 0.75) {
                        let newSpeed = Math.max(50, parseInt(speedControl.value) - 5);
                        speedControl.value = newSpeed;
                        speedInput.value = newSpeed;
                        speedPreset.value = newSpeed;
                        adjustSpeed();
                        localStorage.setItem('speed', newSpeed);
                        showMessage(`속도: ${newSpeed}ms`, 1000);
                    } else if (touchEndX < window.innerWidth * 0.25) {
                        let newSpeed = Math.min(2000, parseInt(speedControl.value) + 5);
                        speedControl.value = newSpeed;
                        speedInput.value = newSpeed;
                        speedPreset.value = newSpeed;
                        adjustSpeed();
                        localStorage.setItem('speed', newSpeed);
                        showMessage(`속도: ${newSpeed}ms`, 1000);
                    }
                } else if (deltaX > 100 && currentPage > 0) {
                    currentPage--;
                    stopEffect();
                    displayPage(-1);
                } else if (deltaX < -100 && currentPage < pages.length - 1) {
                    currentPage++;
                    stopEffect();
                    displayPage(1);
                }
            }
        });

        window.addEventListener('popstate', (e) => {
            if (isFullscreen) {
                e.preventDefault();
                stopEffect();
                exitFullscreen();
                history.pushState(null, null, window.location.href);
            }
        });
        history.pushState(null, null, window.location.href);

        function showToc() {
            if (!book || toc.length === 0) {
                showMessage('목차가 없습니다.', 2000);
                return;
            }
            tocContent.innerHTML = '<ul>' + toc.map((item, index) => {
                return `<li data-page="${index}">${item.label || '제목 없음'}</li>`;
            }).join('') + '</ul>';
            tocOverlay.style.display = 'block';

            tocContent.querySelectorAll('li').forEach(li => {
                li.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const pageIndex = parseInt(li.dataset.page);
                    currentPage = pageIndex;
                    stopEffect();
                    displayPage();
                    tocOverlay.style.display = 'none';
                });
            });

            document.getElementById('closeToc').addEventListener('click', (e) => {
                e.stopPropagation();
                tocOverlay.style.display = 'none';
            });
        }

        resetSettings.addEventListener('click', async () => {
            localStorage.clear();
            await clearIndexedDBCache();
            speedControl.value = 100;
            speedInput.value = 100;
            speedPreset.value = 100;
            mobileSpeedControl.checked = false;
            effectSelect.value = 'char';
            delayBeforeEffect.value = 400;
            fontSize.value = 18;
            fontFamily.value = 'Arial, sans-serif';
            lineHeight.value = 1.6;
            letterSpacing.value = 0;
            preloadRange.value = 2;
            textHeight.value = 70;
            pageInfoSize.value = 16;
            pageInfoOpacity.value = 0.5;
            autoRestart.checked = false;
            pageAnimation.checked = true;
            showPageInfo.checked = true;
            fullscreenMode.checked = false;
            blackMode.checked = false;
            blackModeColor.value = '#2d2d2d';
            marginTop.value = 0;
            marginRight.value = 0;
            marginBottom.value = 0;
            marginLeft.value = 0;
            enableFullScreenButtons.checked = true;
            fullScreenButtonWidth.value = 30;
            fullScreenButtonHeight.value = 100;
            autoPageTurn.checked = true;
            libraryFiles = [];
            localStorage.setItem('libraryFiles', JSON.stringify(libraryFiles));
            showMessage('설정이 초기화되었습니다.', 2000);
            toggleButton.innerText = '시작';
            isTrainingActive = false;
            pages = [];
            textContent.innerHTML = '';
            pageInfo.innerText = '';
            progress.value = 0;
            updateProgressPercent(0);
            updateFullScreenButtons();
            updatePageInfoStyles();
        });

        clearCacheButton.addEventListener('click', async () => {
            await clearIndexedDBCache();
            showMessage('캐시가 비워졌습니다.', 2000);
        });

        retryButton.addEventListener('click', () => {
            retryButton.style.display = 'none';
            handleFileUpload(fileInput.files[0] || null);
        });

        function adjustSpeed() {
            if (interval) {
                clearInterval(interval);
                if (!isPaused) startEffect();
            }
        }

        function previewEffect() {
            stopEffect();
            startEffect();
            setTimeout(stopEffect, 2000);
        }

        function updateProgressPercent(value) {
            progressPercent.innerText = `${Math.round(value)}%`;
            progressPercent.style.display = value > 0 ? 'block' : 'none';
        }

        function updateTextContentStyles() {
            const currentSettings = {
                fontSize: fontSize.value,
                fontFamily: fontFamily.value,
                lineHeight: lineHeight.value,
                letterSpacing: letterSpacing.value
            };
            if (JSON.stringify(currentSettings) === JSON.stringify(lastSettings)) return;
            lastSettings = { ...currentSettings };
            document.documentElement.style.setProperty('--font-size', `${fontSize.value}px`);
            document.documentElement.style.setProperty('--line-height', lineHeight.value);
            document.documentElement.style.setProperty('--letter-spacing', `${letterSpacing.value}px`);
            document.documentElement.style.setProperty('--text-height', `${textHeight.value}vh`);
            document.documentElement.style.setProperty('--margin-top', `${marginTop.value}vh`);
            document.documentElement.style.setProperty('--margin-right', `${marginRight.value}vw`);
            document.documentElement.style.setProperty('--margin-bottom', `${marginBottom.value}vh`);
            document.documentElement.style.setProperty('--margin-left', `${marginLeft.value}vw`);
            updateTextContentMargins();
            toggleBlackMode();
            pages = splitTextToFit(pages.join('\n\n'), textContent.getBoundingClientRect().height);
            preloadPages();
            displayPage();
        }

        function updateTextContentMargins() {
            textContent.style.marginTop = `${marginTop.value}vh`;
            textContent.style.marginRight = `${marginRight.value}vw`;
            textContent.style.marginBottom = `${marginBottom.value}vh`;
            textContent.style.marginLeft = `${marginLeft.value}vw`;
        }

        function updateFullScreenButtons() {
            if (enableFullScreenButtons.checked && isFullscreen) {
                leftPageButton.style.display = 'block';
                rightPageButton.style.display = 'block';
                leftPageButton.style.width = `${fullScreenButtonWidth.value}vw`;
                rightPageButton.style.width = `${fullScreenButtonWidth.value}vw`;
                leftPageButton.style.height = `${fullScreenButtonHeight.value}vh`;
                rightPageButton.style.height = `${fullScreenButtonHeight.value}vh`;
            } else {
                leftPageButton.style.display = 'none';
                rightPageButton.style.display = 'none';
            }
        }

        function updatePageInfoStyles() {
            const opacity = pageInfoOpacity.value;
            pageInfo.style.opacity = opacity;
            speedDownButton.style.opacity = opacity;
            speedUpButton.style.opacity = opacity;
        }

        function toggleButtons(disable) {
            toggleButton.disabled = disable;
            prevPage.disabled = disable;
            nextPage.disabled = disable;
            tocButton.disabled = disable;
            libraryButton.disabled = disable;
            jumpToPage.disabled = disable;
        }

        function toggleBlackMode() {
            document.body.classList.toggle('black-mode', blackMode.checked);
            textContent.style.backgroundColor = blackMode.checked ? blackModeColor.value : '#fff';
            textContent.style.color = blackMode.checked ? '#fff' : '#333';
        }
    </script>
</body>
</html>
