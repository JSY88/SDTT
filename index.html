<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>사라지는 텍스트 훈련</title>
    <style>
        /* 기존 스타일 유지, 변경 없음 */
        :root {
            --font-size: 18px;
            --line-height: 1.6;
            --letter-spacing: 0px;
            --text-height: 70vh;
            --margin-top: 0vh;
            --margin-right: 0vw;
            --margin-bottom: 0vh;
            --margin-left: 0vw;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 5px;
            background-color: #f5f5f5;
            overscroll-behavior: none;
            position: relative;
            touch-action: pan-y;
            overflow-x: hidden;
        }

        #textContent {
            font-size: var(--font-size);
            line-height: var(--line-height);
            letter-spacing: var(--letter-spacing);
            white-space: pre-wrap;
            position: relative;
            overflow-y: hidden;
            overflow-x: hidden;
            width: calc(100% - var(--margin-left) - var(--margin-right));
            height: calc(var(--text-height) - var(--margin-top) - var(--margin-bottom) - 80px);
            margin-top: var(--margin-top);
            margin-right: var(--margin-right);
            margin-bottom: var(--margin-bottom);
            margin-left: var(--margin-left);
            padding: 10px;
            box-sizing: border-box;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            z-index: 1;
            color: #333;
            user-select: none;
            transition: opacity 0.3s;
        }

        #textContent.eink-mode {
            background-color: #000 !important;
            color: #000 !important;
        }

        #controls {
            margin: 10px 0;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
            position: relative;
        }

        #toggleButton {
            padding: 8px 16px;
            font-size: 16px;
        }

        .fullscreen #toggleButton {
            display: none;
        }

        #message {
            color: red;
            position: fixed;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 1001;
            display: none;
        }

        #retryButton {
            position: fixed;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 12px;
            font-size: 14px;
            border: none;
            border-radius: 5px;
            background-color: #e74c3c;
            color: white;
            cursor: pointer;
            display: none;
            z-index: 11;
        }

        #retryButton:hover {
            background-color: #c0392b;
        }

        #pageInfoContainer {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 1000;
            display: none;
        }

        #pageInfo {
            font-size: 16px;
            background: transparent;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            border: none;
            color: #333;
            opacity: 0.5;
            transition: opacity 0.3s;
        }

        #pageInfo:hover {
            opacity: 0.8;
        }

        #speedDownButton, #speedUpButton {
            width: 50px;
            height: 50px;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 20px;
            color: #333;
            opacity: 0.5;
            transition: opacity 0.3s;
        }

        #speedDownButton:hover, #speedUpButton:hover {
            opacity: 0.8;
        }

        #leftPageButton, #rightPageButton {
            display: none;
            position: fixed;
            top: 0;
            height: 100vh;
            width: 30vw;
            background: rgba(0, 0, 0, 0);
            border: none;
            z-index: 999;
            cursor: pointer;
            transition: none;
        }

        #leftPageButton:hover, #rightPageButton:hover,
        #leftPageButton:focus, #rightPageButton:focus,
        #leftPageButton:active, #rightPageButton:active {
            background: rgba(0, 0, 0, 0);
            transform: none;
            outline: none;
        }

        #leftPageButton {
            left: 0;
        }

        #rightPageButton {
            right: 0;
        }

        .fullscreen #leftPageButton, .fullscreen #rightPageButton {
            display: block;
        }

        #progressContainer {
            position: relative;
            width: 100%;
            margin: 5px 0;
        }

        #progress {
            width: 100%;
            height: 4px;
            opacity: 0.7;
            transition: none;
        }

        #progressPercent {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #333;
            display: none;
        }

        #loadingSpinner {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            z-index: 5;
        }

        button {
            padding: 8px 12px;
            font-size: 14px;
            border: none;
            border-radius: 5px;
            background-color: #3498db;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
            max-width: 100px;
        }

        button:hover {
            background-color: #2980b9;
            transform: scale(1.05);
        }

        button:focus {
            outline: 2px solid #2980b9;
            outline-offset: 2px;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        details {
            margin: 10px 0;
            width: 100%;
            z-index: 30;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        summary {
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }

        #advancedControls {
            padding: 15px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            align-items: center;
        }

        #advancedControls label {
            font-size: 14px;
            color: #333;
        }

        #advancedControls input[type="text"],
        #advancedControls input[type="range"],
        #advancedControls select,
        #advancedControls input[type="color"] {
            width: 100%;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }

        #advancedControls input[type="checkbox"] {
            margin-left: 5px;
        }

        #advancedControls button {
            max-width: none;
            width: 100%;
        }

        @keyframes charFade {
            to { opacity: 0; }
        }

        .char-span {
            transition: none;
        }

        .char-span.fade {
            animation: charFade 0.3s forwards;
        }

        .char-span.current {
            background-color: transparent;
        }

        .char-span.eink-black {
            background-color: #000 !important;
            color: #000 !important;
        }

        .line {
            display: block;
            transition: opacity 0.2s;
        }

        .line.hidden {
            opacity: 0;
        }

        .fullscreen #controls, .fullscreen #progressContainer, .fullscreen #message, .fullscreen #retryButton, .fullscreen details, .fullscreen #fileUpload {
            display: none;
        }

        .fullscreen #textContent {
            width: 100vw;
            height: 100vh;
            margin: 0;
            padding: 20px;
        }

        .fullscreen #pageInfoContainer {
            display: flex;
        }

        #fileUpload {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            border: 2px dashed #3498db;
            border-radius: 5px;
            text-align: center;
            font-size: 16px;
            background-color: #f9f9f9;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #fileUpload:hover, #fileUpload.dragover {
            background-color: #e6f0fa;
        }

        #tocOverlay, #libraryOverlay, #favoritesOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 20;
            color: white;
            padding: 20px;
            overflow-y: auto;
        }

        #tocOverlay ul, #libraryOverlay ul, #favoritesOverlay ul {
            list-style: none;
            padding: 0;
        }

        #tocOverlay li, #libraryOverlay li, #favoritesOverlay li {
            padding: 10px;
            cursor: pointer;
        }

        #tocOverlay li:hover, #libraryOverlay li:hover, #favoritesOverlay li:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        #libraryOverlay .library-item, #favoritesOverlay .favorites-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        #libraryOverlay .library-item img, #favoritesOverlay .favorites-item img {
            width: 50px;
            height: 70px;
            object-fit: cover;
        }

        #libraryOverlay .library-item .no-cover, #favoritesOverlay .favorites-item .no-cover {
            width: 50px;
            height: 70px;
            background: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 12px;
            color: #fff;
        }

        #libraryOverlay .library-item button, #favoritesOverlay .favorites-item button {
            margin-left: 10px;
            padding: 2px 5px;
            font-size: 12px;
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        #libraryOverlay .library-item button:hover, #favoritesOverlay .favorites-item button:hover {
            background-color: #c0392b;
        }

        #libraryOverlay .library-item .favorite-button, #favoritesOverlay .favorites-item .favorite-button {
            background: none;
            font-size: 16px;
            color: #ccc;
        }

        #libraryOverlay .library-item .favorite-button.favorited, #favoritesOverlay .favorites-item .favorite-button.favorited {
            color: #FFD700;
        }

        #closeToc, #closeLibrary, #closeFavorites {
            font-size: 18px;
            background-color: #fff;
            color: #000;
            border: 1px solid #000;
            padding: 5px 10px;
            cursor: pointer;
        }

        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }

        @media (max-width: 600px) {
            body { padding: 5px; }
            #textContent {
                font-size: 16px;
                height: calc(var(--text-height) - 60px);
                padding: 8px;
            }
            #controls {
                flex-direction: column;
                gap: 3px;
            }
            button {
                padding: 8px 12px;
                font-size: 14px;
                max-width: 100%;
            }
            #advancedControls {
                grid-template-columns: 1fr;
                gap: 8px;
            }
            #pageInfo {
                font-size: 14px;
                padding: 6px 12px;
            }
            #speedDownButton, #speedUpButton {
                width: 40px;
                height: 40px;
                font-size: 18px;
            }
            #message {
                bottom: 80px;
                font-size: 14px;
            }
        }

        .black-mode body { background-color: #1a1a1a; }
        .black-mode #textContent { background-color: #2d2d2d; color: #fff; border-color: #444; }
        .black-mode summary { background-color: #3a3a3a; }
        .black-mode #fileUpload { background-color: #333; border-color: #555; }
        .black-mode #fileUpload:hover { background-color: #444; }
        .black-mode #pageInfo, .black-mode #speedDownButton, .black-mode #speedUpButton { color: #fff; }

        #timerSettings {
            display: none;
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 1002;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            width: 80%;
            max-width: 600px;
        }

        .setConfig {
            margin-bottom: 10px;
            display: flex;
            gap: 5px;
            align-items: center;
        }

        #timerSettings input[type="number"] {
            width: 60px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        #timerSettings select {
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        #timerSettings button {
            padding: 5px 10px;
            font-size: 12px;
            max-width: none;
        }

        #timerSettings label {
            font-size: 12px;
            color: #333;
        }

        #timerSettings .sound-select {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        #timerSettings .sound-select select {
            flex: 1;
        }

        #bookmarkButton {
            padding: 5px 10px;
            font-size: 12px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #bookmarkList {
            position: fixed;
            top: 40px;
            right: 10px;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 1002;
            display: none;
        }

        #bookmarkList ul {
            list-style: none;
            padding: 0;
        }

        #bookmarkList li {
            padding: 5px 0;
            cursor: pointer;
        }

        #timerProgress {
            position: fixed;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 1002;
            display: none;
        }

        #recordButton {
            padding: 5px 10px;
            font-size: 12px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #recordList {
            position: fixed;
            top: 40px;
            left: 10px;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 1002;
            display: none;
        }

        #recordList ul {
            list-style: none;
            padding: 0;
        }

        #recordList li {
            padding: 5px 0;
        }
    </style>
    <!-- CDN 최적화: 최신 버전의 EPUB.js와 JSZip 사용 -->
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nosleep.js@1.1.0/dist/NoSleep.min.js"></script>
    <script src="https://unpkg.com/epubjs@latest/dist/epub.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
    <input type="file" id="fileUpload" accept=".txt,.epub" aria-label="파일 업로드" multiple>
    <div id="controls" role="toolbar">
        <button id="toggleButton" aria-label="훈련 시작/중지">시작</button>
        <button id="tocButton" aria-label="목차">목차</button>
        <button id="libraryButton" aria-label="라이브러리">라이브러리</button>
        <button id="favoritesButton" aria-label="즐겨찾기">즐겨찾기</button>
        <button id="bookmarkButton" aria-label="북마크">북마크</button>
        <button id="recordButton" aria-label="기록">기록</button>
        <input type="number" id="jumpToPage" min="1" placeholder="페이지로 이동" style="width: 100px; padding: 5px;">
    </div>
    <details>
        <summary>고급 설정</summary>
        <div id="advancedControls">
            <label for="speedControl">속도 (50ms ~ 2000ms):</label>
            <div><input type="range" id="speedControl" min="50" max="2000" step="1" value="100">
                 <input type="text" id="speedInput" value="100" style="width: 80px;"></div>
            <label for="speedPreset">속도 프리셋:</label>
            <select id="speedPreset">
                <option value="50">빠르게</option>
                <option value="100" selected>보통</option>
                <option value="200">느리게</option>
            </select>
            <label for="mobileSpeedControl">모바일 속도 조절:</label>
            <input type="checkbox" id="mobileSpeedControl">
            <label for="effectSelect">효과 선택:</label>
            <select id="effectSelect">
                <option value="char" selected>글자 단위 소멸</option>
                <option value="fade">페이드 아웃</option>
                <option value="eink">전자잉크 모드</option>
            </select>
            <label for="delayBeforeEffect">효과 시작 전 딜레이 (ms):</label>
            <div><input type="text" id="delayBeforeEffect" value="400"></div>
            <label for="fontSize">글꼴 크기:</label>
            <div><input type="text" id="fontSize" value="18">px</div>
            <label for="fontFamily">글꼴 스타일:</label>
            <select id="fontFamily">
                <option value="Arial, sans-serif">Arial</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="'Noto Sans KR', sans-serif">Noto Sans KR</option>
            </select>
            <label for="lineHeight">줄 간격:</label>
            <div><input type="text" id="lineHeight" value="1.6"></div>
            <label for="letterSpacing">글자 간격:</label>
            <div><input type="text" id="letterSpacing" value="0">px</div>
            <label for="preloadRange">프리로드 범위 (±페이지):</label>
            <div><input type="text" id="preloadRange" value="2"></div>
            <label for="textHeight">텍스트 영역 높이 (%):</label>
            <div><input type="text" id="textHeight" value="70"></div>
            <label for="pageInfoSize">페이지 표시 크기:</label>
            <div><input type="text" id="pageInfoSize" value="16">px</div>
            <label for="pageInfoOpacity">페이지 버튼 투명도 (0~1):</label>
            <div><input type="range" id="pageInfoOpacity" min="0" max="1" step="0.1" value="0.5"></div>
            <label for="autoRestart">페이지 전환 시 재시작:</label>
            <input type="checkbox" id="autoRestart">
            <label for="pageAnimation">페이지 전환 애니메이션:</label>
            <input type="checkbox" id="pageAnimation" checked>
            <label for="showProgress">진행 정보 표시:</label>
            <input type="checkbox" id="showProgress" checked>
            <label for="showPageInfo">페이지 번호 표시:</label>
            <input type="checkbox" id="showPageInfo" checked>
            <label for="fullscreenMode">전체 화면 모드:</label>
            <input type="checkbox" id="fullscreenMode">
            <label for="blackMode">블랙 모드:</label>
            <input type="checkbox" id="blackMode">
            <label for="blackModeColor">블랙 모드 색상:</label>
            <input type="color" id="blackModeColor" value="#2d2d2d">
            <label for="marginTop">위쪽 여백 (%):</label>
            <div><input type="text" id="marginTop" value="0"></div>
            <label for="marginRight">오른쪽 여백 (%):</label>
            <div><input type="text" id="marginRight" value="0"></div>
            <label for="marginBottom">아래쪽 여백 (%):</label>
            <div><input type="text" id="marginBottom" value="0"></div>
            <label for="marginLeft">왼쪽 여백 (%):</label>
            <div><input type="text" id="marginLeft" value="0"></div>
            <label for="enableFullScreenButtons">전체화면 버튼 활성화:</label>
            <input type="checkbox" id="enableFullScreenButtons" checked>
            <label for="fullScreenButtonWidth">전체화면 버튼 너비 (%):</label>
            <div><input type="text" id="fullScreenButtonWidth" value="30"></div>
            <label for="fullScreenButtonHeight">전체화면 버튼 높이 (%):</label>
            <div><input type="text" id="fullScreenButtonHeight" value="100"></div>
            <label for="autoPageTurn">글자 사라짐 후 자동 페이지 넘김:</label>
            <input type="checkbox" id="autoPageTurn" checked>
            <button id="resetSettings" aria-label="설정 초기화">설정 초기화</button>
            <button id="clearCacheButton" aria-label="캐시 비우기">캐시 비우기</button>
        </div>
    </details>
    <div id="progressContainer">
        <progress id="progress" value="0" max="100"></progress>
        <span id="progressPercent">0%</span>
    </div>
    <div id="textContent" role="region" aria-label="텍스트 표시 영역"></div>
    <div id="pageInfoContainer">
        <button id="speedDownButton" aria-label="속도 감소">-</button>
        <button id="pageInfo" aria-live="polite"></button>
        <button id="speedUpButton" aria-label="속도 증가">+</button>
    </div>
    <button id="leftPageButton" aria-label="이전 페이지로 이동"></button>
    <button id="rightPageButton" aria-label="다음 페이지로 이동"></button>
    <div id="loadingSpinner"></div>
    <div id="message" aria-live="assertive"></div>
    <button id="retryButton" aria-label="재시도">재시도</button>
    <div id="tocOverlay">
        <button id="closeToc">X</button>
        <div id="tocContent"></div>
    </div>
    <div id="libraryOverlay">
        <button id="closeLibrary">X</button>
        <div class="library-controls">
            <input type="search" id="librarySearch" placeholder="검색...">
            <select id="librarySort">
                <option value="recent">최근 열람순</option>
                <option value="name">이름순</option>
                <option value="title">제목순</option>
                <option value="added">추가순</option>
            </select>
            <button id="addFilesButton">파일/폴더 추가</button>
        </div>
        <div id="libraryContent"></div>
    </div>
    <div id="favoritesOverlay">
        <button id="closeFavorites">X</button>
        <div class="favorites-controls">
            <input type="search" id="favoritesSearch" placeholder="검색...">
            <select id="favoritesSort">
                <option value="recent">최근 열람순</option>
                <option value="name">이름순</option>
                <option value="title">제목순</option>
                <option value="added">추가순</option>
            </select>
        </div>
        <div id="favoritesContent"></div>
    </div>
    <div id="timerSettings">
        <label for="setCount">세트 횟수:</label>
        <input type="number" id="setCount" min="1" value="1">
        <div id="setConfigs">
            <div class="setConfig">
                <label>읽는 시간 (분:초):</label>
                <input type="number" class="readMinutes" min="0" value="0">
                <input type="number" class="readSeconds" min="0" max="59" value="0">
                <label>일시정지 시간 (분:초):</label>
                <input type="number" class="pauseMinutes" min="0" value="0">
                <input type="number" class="pauseSeconds" min="0" max="59" value="0">
                <label>대기 시간 (초):</label>
                <input type="number" class="waitTime" min="0" value="0">
            </div>
        </div>
        <button id="addSetConfig">구성 추가</button>
        <button id="saveConfig">구성 저장</button>
        <button id="loadConfig">구성 불러오기</button>
        <button id="startTimer">타이머 시작</button>
        <button id="pauseTimer">타이머 일시정지</button>
        <button id="stopTimer">타이머 정지</button>
        <div class="sound-select">
            <label>시작 소리:</label>
            <select id="startSound">
                <option value="">선택 안함</option>
                <option value="piano">피아노 음</option>
                <option value="alarm1.mp3">알람1</option>
                <option value="alarm2.mp3">알람2</option>
            </select>
        </div>
        <div class="sound-select">
            <label>읽기 종료 소리:</label>
            <select id="readEndSound">
                <option value="">선택 안함</option>
                <option value="piano">피아노 음</option>
                <option value="alarm1.mp3">알람1</option>
                <option value="alarm2.mp3">알람2</option>
            </select>
        </div>
        <div class="sound-select">
            <label>일시정지 종료 소리:</label>
            <select id="pauseEndSound">
                <option value="">선택 안함</option>
                <option value="piano">피아노 음</option>
                <option value="alarm1.mp3">알람1</option>
                <option value="alarm2.mp3">알람2</option>
            </select>
        </div>
        <div class="sound-select">
            <label>모든 세트 종료 소리:</label>
            <select id="allSetsEndSound">
                <option value="">선택 안함</option>
                <option value="piano">피아노 음</option>
                <option value="alarm1.mp3">알람1</option>
                <option value="alarm2.mp3">알람2</option>
            </select>
        </div>
    </div>
    <div id="bookmarkList">
        <ul></ul>
    </div>
    <div id="timerProgress">
        <p>타이머 진행 상황: <span id="timerStatus"></span></p>
        <p>읽은 글자 수: <span id="readChars"></span></p>
        <p>사라짐 속도 (평균): <span id="avgSpeed"></span>ms</p>
        <p>경과 시간: <span id="elapsedTime"></span></p>
    </div>
    <div id="recordList">
        <ul></ul>
    </div>

    <script>
        let noSleep;
        let currentEffectIndex = 0;
        if (typeof NoSleep !== 'undefined') {
            noSleep = new NoSleep();
        } else {
            console.warn('NoSleep.js 로드 실패. 화면 잠금 방지 기능이 작동하지 않습니다.');
        }

        const fileInput = document.getElementById('fileUpload');
        const textContent = document.getElementById('textContent');
        const speedControl = document.getElementById('speedControl');
        const speedInput = document.getElementById('speedInput');
        const speedPreset = document.getElementById('speedPreset');
        const mobileSpeedControl = document.getElementById('mobileSpeedControl');
        const effectSelect = document.getElementById('effectSelect');
        const delayBeforeEffect = document.getElementById('delayBeforeEffect');
        const fontSize = document.getElementById('fontSize');
        const fontFamily = document.getElementById('fontFamily');
        const lineHeight = document.getElementById('lineHeight');
        const letterSpacing = document.getElementById('letterSpacing');
        const preloadRange = document.getElementById('preloadRange');
        const textHeight = document.getElementById('textHeight');
        const pageInfoSize = document.getElementById('pageInfoSize');
        const pageInfoOpacity = document.getElementById('pageInfoOpacity');
        const autoRestart = document.getElementById('autoRestart');
        const pageAnimation = document.getElementById('pageAnimation');
        const showPageInfo = document.getElementById('showPageInfo');
        const fullscreenMode = document.getElementById('fullscreenMode');
        const blackMode = document.getElementById('blackMode');
        const blackModeColor = document.getElementById('blackModeColor');
        const marginTop = document.getElementById('marginTop');
        const marginRight = document.getElementById('marginRight');
        const marginBottom = document.getElementById('marginBottom');
        const marginLeft = document.getElementById('marginLeft');
        const enableFullScreenButtons = document.getElementById('enableFullScreenButtons');
        const fullScreenButtonWidth = document.getElementById('fullScreenButtonWidth');
        const fullScreenButtonHeight = document.getElementById('fullScreenButtonHeight');
        const autoPageTurn = document.getElementById('autoPageTurn');
        const toggleButton = document.getElementById('toggleButton');
        const tocButton = document.getElementById('tocButton'); // zelenýId 대신 tocButton 사용
        const libraryButton = document.getElementById('libraryButton');
        const favoritesButton = document.getElementById('favoritesButton');
        const bookmarkButton = document.getElementById('bookmarkButton');
        const recordButton = document.getElementById('recordButton');
        const jumpToPage = document.getElementById('jumpToPage');
        const pageInfo = document.getElementById('pageInfo');
        const speedDownButton = document.getElementById('speedDownButton');
        const speedUpButton = document.getElementById('speedUpButton');
        const leftPageButton = document.getElementById('leftPageButton');
        const rightPageButton = document.getElementById('rightPageButton');
        const message = document.getElementById('message');
        const progress = document.getElementById('progress');
        const progressPercent = document.getElementById('progressPercent');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const retryButton = document.getElementById('retryButton');
        const resetSettings = document.getElementById('resetSettings');
        const tocOverlay = document.getElementById('tocOverlay');
        const tocContent = document.getElementById('tocContent');
        const libraryOverlay = document.getElementById('libraryOverlay');
        const libraryContent = document.getElementById('libraryContent');
        const favoritesOverlay = document.getElementById('favoritesOverlay');
        const favoritesContent = document.getElementById('favoritesContent');
        const clearCacheButton = document.getElementById('clearCacheButton');
        const pageInfoContainer = document.getElementById('pageInfoContainer');
        const bookmarkList = document.getElementById('bookmarkList');
        const recordList = document.getElementById('recordList');

        // 타이머 설정 요소
        const timerSettings = document.getElementById('timerSettings');
        const setCount = document.getElementById('setCount');
        const setConfigs = document.getElementById('setConfigs');
        const addSetConfig = document.getElementById('addSetConfig');
        const saveConfig = document.getElementById('saveConfig');
        const loadConfig = document.getElementById('loadConfig');
        const startTimerButton = document.getElementById('startTimer');
        const pauseTimerButton = document.getElementById('pauseTimer');
        const stopTimerButton = document.getElementById('stopTimer');
        const startSound = document.getElementById('startSound');
        const readEndSound = document.getElementById('readEndSound');
        const pauseEndSound = document.getElementById('pauseEndSound');
        const allSetsEndSound = document.getElementById('allSetsEndSound');

        // 타이머 진행 상황 요소
        const timerProgress = document.getElementById('timerProgress');
        const timerStatus = document.getElementById('timerStatus');
        const readChars = document.getElementById('readChars');
        const avgSpeed = document.getElementById('avgSpeed');
        const elapsedTime = document.getElementById('elapsedTime');

        let interval, pages = [], currentPage = 0, book, toc = [];
        let worker, lastFileName = '';
        let renderedPages = [];
        let isFullscreen = false;
        let libraryFiles = JSON.parse(localStorage.getItem('libraryFiles')) || [];
        let favorites = JSON.parse(localStorage.getItem('favorites')) || [];
        let isTrainingActive = false;
        let messageTimer;
        let lastSettings = {};
        let isPaused = false;
        let lastTouchTime = 0;
        let sliderContainer = null;
        let isPageTurning = false;
        let timerInterval = null;
        let currentSet = 0;
        let currentConfigIndex = 0;
        let isReading = true;
        let totalSets = 0;
        let configs = [];
        let startWaitTime = 0;
        let setWaitTime = 0;
        let audioContext = null;
        let bookmarks = JSON.parse(localStorage.getItem('bookmarks')) || [];
        let records = JSON.parse(localStorage.getItem('records')) || [];
        let totalReadChars = 0;
        let totalReadTime = 0;
        let speedSum = 0;
        let speedCount = 0;
        let timerStartTime = 0;

        const DB_NAME = 'vanishingTextDB';
        const DB_VERSION = 1;
        const CACHE_STORE_NAME = 'fileCacheStore';
        let db;

        const dbPromise = new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);

            request.onerror = (event) => {
                console.error('IndexedDB 초기화 오류:', event);
                reject(event);
            };

            request.onsuccess = (event) => {
                db = event.target.result;
                resolve();
            };

            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(CACHE_STORE_NAME)) {
                    db.createObjectStore(CACHE_STORE_NAME);
                }
            };
        });

        // IndexedDB 함수들: EPUB 캐싱을 위해 사용
        async function getCachedData(fileName) {
            await dbPromise.catch(() => {});
            return new Promise((resolve) => {
                if (!db) {
                    resolve(null);
                    return;
                }
                const transaction = db.transaction([CACHE_STORE_NAME], 'readonly');
                const store = transaction.objectStore(CACHE_STORE_NAME);
                const request = store.get(fileName);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => resolve(null);
            });
        }

        async function setCachedData(fileName, data) {
            await dbPromise.catch(() => {});
            return new Promise((resolve) => {
                if (!db) {
                    resolve();
                    return;
                }
                const transaction = db.transaction([CACHE_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(CACHE_STORE_NAME);
                const request = store.put(data, fileName);
                request.onsuccess = () => resolve();
                request.onerror = () => resolve();
            });
        }

        async function deleteCachedData(fileName) {
            await dbPromise.catch(() => {});
            return new Promise((resolve) => {
                if (!db) {
                    resolve();
                    return;
                }
                const transaction = db.transaction([CACHE_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(CACHE_STORE_NAME);
                const request = store.delete(fileName);
                request.onsuccess = () => resolve();
                request.onerror = () => resolve();
            });
        }

        async function clearIndexedDBCache() {
            await dbPromise.catch(() => {});
            return new Promise((resolve) => {
                if (!db) {
                    resolve();
                    return;
                }
                const transaction = db.transaction([CACHE_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(CACHE_STORE_NAME);
                const request = store.clear();
                request.onsuccess = () => resolve();
                request.onerror = () => resolve();
            });
        }

        async function pruneFileCache() {
            await dbPromise.catch(() => {});
            const MAX_CACHE_ENTRIES = 5;
            const cachedFiles = [];

            return new Promise((resolve) => {
                if (!db) {
                    resolve();
                    return;
                }
                const transaction = db.transaction([CACHE_STORE_NAME], 'readonly');
                const store = transaction.objectStore(CACHE_STORE_NAME);
                const request = store.openCursor();
                request.onsuccess = async function(event) {
                    const cursor = event.target.result;
                    if (cursor) {
                        const fileName = cursor.key;
                        const cacheEntry = cursor.value;
                        cachedFiles.push({ name: fileName, timestamp: cacheEntry.timestamp || Date.now() });
                        cursor.continue();
                    } else {
                        cachedFiles.sort((a, b) => a.timestamp - b.timestamp);
                        while (cachedFiles.length > MAX_CACHE_ENTRIES) {
                            const fileToRemove = cachedFiles.shift();
                            await deleteCachedData(fileToRemove.name);
                        }
                        resolve();
                    }
                };
                request.onerror = () => resolve();
            });
        }

        // 설정 초기화
        speedControl.value = localStorage.getItem('speed') || 100;
        speedInput.value = localStorage.getItem('speed') || 100;
        speedPreset.value = localStorage.getItem('speedPreset') || 100;
        mobileSpeedControl.checked = localStorage.getItem('mobileSpeedControl') === 'true';
        effectSelect.value = localStorage.getItem('effect') || 'char';
        delayBeforeEffect.value = localStorage.getItem('delayBeforeEffect') || 400;
        fontSize.value = localStorage.getItem('fontSize') || 18;
        fontFamily.value = localStorage.getItem('fontFamily') || 'Arial, sans-serif';
        lineHeight.value = localStorage.getItem('lineHeight') || 1.6;
        letterSpacing.value = localStorage.getItem('letterSpacing') || 0;
        preloadRange.value = localStorage.getItem('preloadRange') || 2;
        textHeight.value = localStorage.getItem('textHeight') || 70;
        pageInfoSize.value = localStorage.getItem('pageInfoSize') || 16;
        pageInfoOpacity.value = localStorage.getItem('pageInfoOpacity') || 0.5;
        autoRestart.checked = localStorage.getItem('autoRestart') === 'true';
        pageAnimation.checked = localStorage.getItem('pageAnimation') !== 'false';
        showPageInfo.checked = localStorage.getItem('showPageInfo') !== 'false';
        fullscreenMode.checked = localStorage.getItem('fullscreenMode') === 'true';
        blackMode.checked = localStorage.getItem('blackMode') === 'true';
        blackModeColor.value = localStorage.getItem('blackModeColor') || '#2d2d2d';
        marginTop.value = localStorage.getItem('marginTop') || 0;
        marginRight.value = localStorage.getItem('marginRight') || 0;
        marginBottom.value = localStorage.getItem('marginBottom') || 0;
        marginLeft.value = localStorage.getItem('marginLeft') || 0;
        enableFullScreenButtons.checked = localStorage.getItem('enableFullScreenButtons') !== 'false';
        fullScreenButtonWidth.value = localStorage.getItem('fullScreenButtonWidth') || 30;
        fullScreenButtonHeight.value = localStorage.getItem('fullScreenButtonHeight') || 100;
        autoPageTurn.checked = localStorage.getItem('autoPageTurn') !== 'false';
        updateTextContentStyles();
        toggleBlackMode();
        updateFullScreenButtons();
        updatePageInfoStyles();

        // 웹 워커 초기화
        if (window.Worker) {
            const workerCode = `
                self.onmessage = function(e) {
                    const { text, maxHeight, fontSize, lineHeight, letterSpacing, fontFamily } = e.data;
                    const lines = text.split('\\n').filter(line => line.trim().length > 0);
                    const pages = [];
                    let currentPageText = '';
                    const lineHeightPx = parseFloat(lineHeight) * parseFloat(fontSize);
                    let currentHeight = 0;
                    for (let line of lines) {
                        currentHeight += lineHeightPx;
                        if (currentHeight > maxHeight) {
                            pages.push(currentPageText.trim());
                            currentPageText = line + '\\n';
                            currentHeight = lineHeightPx;
                        } else {
                            currentPageText += line + '\\n';
                        }
                    }
                    if (currentPageText.trim().length > 0) pages.push(currentPageText.trim());
                    self.postMessage({ pages });
                };
            `;
            worker = new Worker(URL.createObjectURL(new Blob([workerCode], { type: 'application/javascript' })));
        }

        function addToLibrary(fileName, fileData, coverUrl) {
            const existingIndex = libraryFiles.findIndex(item => item.name === fileName);
            if (existingIndex !== -1) {
                const existingFile = libraryFiles[existingIndex];
                libraryFiles.splice(existingIndex, 1);
                libraryFiles.unshift({ name: fileName, data: fileData, cover: coverUrl, timestamp: Date.now(), isFavorite: existingFile.isFavorite || false });
            } else {
                libraryFiles.unshift({ name: fileName, data: fileData, cover: coverUrl, timestamp: Date.now(), isFavorite: false });
            }
            libraryFiles = libraryFiles.slice(0, 10);
            localStorage.setItem('libraryFiles', JSON.stringify(libraryFiles));
            pruneFileCache();
            console.log(`라이브러리에 파일 추가됨: ${fileName}`);
        }

        // 파일 업로드 이벤트
        fileInput.addEventListener('change', function(event) {
            handleFileUpload(event.target.files[0]);
        });

        fileInput.addEventListener('dragover', (e) => {
            e.preventDefault();
            fileInput.classList.add('dragover');
        });

        fileInput.addEventListener('dragleave', () => {
            fileInput.classList.remove('dragover');
        });

        fileInput.addEventListener('drop', (e) => {
            e.preventDefault();
            fileInput.classList.remove('dragover');
            handleFileUpload(e.dataTransfer.files[0]);
        });

        function showMessage(text, duration = 3000) {
            message.innerText = text;
            message.style.display = 'block';
            clearTimeout(messageTimer);
            messageTimer = setTimeout(() => {
                message.style.display = 'none';
            }, duration);
        }

// EPUB 라이브러리 로드 함수: JSZip과 EPUB.js의 로드 순서 및 초기화 보장
async function loadEpubLibraries() {
    const TIMEOUT_MS = 10000;

    // JSZip 로드
    if (!window.JSZip) {
        showMessage('JSZip 라이브러리 로드 중...');
        console.log('미친 학자: JSZip 로드를 시작합니다. 시간:', new Date().toISOString());
        const script2 = document.createElement('script');
        script2.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        document.head.appendChild(script2);
        await Promise.race([
            new Promise((resolve, reject) => {
                script2.onload = () => {
                    console.log('미친 학자: JSZip 로드 완료! window.JSZip 존재:', !!window.JSZip);
                    resolve();
                };
                script2.onerror = () => reject(new Error('JSZip 로드 실패'));
            }),
            new Promise((_, reject) => setTimeout(() => reject(new Error('JSZip 로드 타임아웃')), TIMEOUT_MS))
        ]);
    }

    // EPUB.js 로드
    if (!window.ePub) {
        showMessage('EPUB.js 라이브러리 로드 중...');
        console.log('미친 학자: EPUB.js 로드를 시작합니다. 시간:', new Date().toISOString());
        const script1 = document.createElement('script');
        script1.src = 'https://unpkg.com/epubjs@0.3.93/dist/epub.min.js';
        document.head.appendChild(script1);
        await Promise.race([
            new Promise((resolve, reject) => {
                script1.onload = () => {
                    console.log('미친 학자: EPUB.js 로드 완료! window.ePub 존재:', !!window.ePub);
                    resolve();
                };
                script1.onerror = () => reject(new Error('EPUB.js 로드 실패'));
            }),
            new Promise((_, reject) => setTimeout(() => reject(new Error('EPUB.js 로드 타임아웃')), TIMEOUT_MS))
        ]);
    }

    // JSZip 강제 할당 (호환성 보장)
    if (window.JSZip && window.ePub) {
        window.ePub.defaults = window.ePub.defaults || {};
        window.ePub.defaults.zip = window.JSZip; // EPUB.js에 JSZip 강제 연결
        console.log('미친 학자: JSZip을 EPUB.js에 강제로 연결했습니다.');
    } else {
        throw new Error('JSZip 또는 EPUB.js가 로드되지 않았습니다.');
    }

    console.log('미친 학자: 모든 라이브러리 로드 성공! JSZip과 EPUB.js 준비 완료.');
}








// 파일 업로드 처리 함수: EPUB 캐싱 및 JSZip 전달 개선
async function handleFileUpload(file) {
    await pruneFileCache();
    if (!file) {
        showMessage('파일을 선택해주세요.');
        loadingSpinner.style.display = 'none';
        return;
    }

    lastFileName = file.name;
    showMessage('파일 로딩 중...');
    loadingSpinner.style.display = 'block';

    const reader = new FileReader();
    reader.onload = async function(event) {
        const fileData = event.target.result;

        if (file.name.endsWith('.epub')) {
            console.log('미친 학자: EPUB 파일 처리 시작:', lastFileName);
            try {
                await loadEpubLibraries();
                console.log('미친 학자: 라이브러리 로드 완료 후 점검 - JSZip:', !!window.JSZip, 'ePub:', !!window.ePub);

                if (!window.ePub || !window.JSZip) {
                    throw new Error('EPUB.js 또는 JSZip 라이브러리가 로드되지 않았습니다.');
                }

                console.log('미친 학자: EPUB 객체 생성 시도');
                // JSZip 명시적 전달 + 전역 연결 확인
                book = window.ePub(fileData, { zip: window.JSZip });
                console.log('미친 학자: EPUB 객체 생성 성공!');
                await book.ready;

                showMessage('EPUB 파싱 중...');
                const coverBlob = await book.coverUrl();
                let coverUrl = coverBlob ? URL.createObjectURL(coverBlob) : null;
                const pagesData = await loadEpubPages();
                pages = pagesData;
                const nav = await book.loaded.navigation;
                toc = nav.toc;

                await setCachedData(lastFileName, { pages: pages, toc: toc, coverUrl: coverUrl, timestamp: Date.now() });

                console.log('미친 학자: EPUB 데이터 캐싱 완료, 페이지 수:', pages.length);
                loadLastPage();
                preloadPages();
                displayPage();
                showMessage('');
                loadingSpinner.style.display = 'none';
            } catch (err) {
                console.error('미친 학자: EPUB 로드 오류 발생:', err.message, '스택:', err.stack);
                showMessage(`EPUB 파일을 열 수 없습니다: ${err.message}`);
                loadingSpinner.style.display = 'none';
                retryButton.style.display = 'block';
            }
        }
    };
    reader.readAsArrayBuffer(file);
}





        async function loadEpubPages() {
            try {
                if (!book.rendition) {
                    book.rendition = book.renderTo('textContent', {
                        ignoreContainerRead: true,
                        flow: 'paginated',
                        width: '100%',
                        height: '100%'
                    });
                }
                let fullText = '';
                const sections = book.spine.items;
                for (let i = 0; i < sections.length; i++) {
                    try {
                        const section = book.spine.get(i);
                        const content = await section.load(book.load.bind(book));
                        progress.value = (i / sections.length) * 50 + 50;
                        const text = content.innerText.trim();
                        if (text) fullText += text + '\n\n';
                        section.unload();
                        console.log(`섹션 ${i + 1}/${sections.length} 로드 성공`); // 디버깅 로그
                    } catch (e) {
                        console.warn(`섹션 ${i + 1} 로드 실패, 건너뜁니다:`, e);
                        continue;
                    }
                }
                return splitTextToFit(fullText, textContent.getBoundingClientRect().height);
            } catch (err) {
                console.error('EPUB 페이지 로드 중 오류 발생:', err);
                showMessage('EPUB 페이지 로드 오류: ' + err.message, 5000);
                throw err;
            }
        }

        function splitTextToFit(text, containerHeight) {
            const lines = text.split('\n').filter(line => line.trim().length > 0);
            const pages = [];
            let currentPageText = '';
            const testDiv = document.createElement('div');
            testDiv.style.cssText = `font-size: ${fontSize.value}px; line-height: ${lineHeight.value}; white-space: pre-wrap; visibility: hidden; position: absolute; padding: 10px; font-family: ${fontFamily.value}; letter-spacing: ${letterSpacing.value}px;`;
            document.body.appendChild(testDiv);
            for (let line of lines) {
                testDiv.innerText = currentPageText + line + '\n';
                if (testDiv.getBoundingClientRect().height > containerHeight) {
                    pages.push(currentPageText.trim());
                    currentPageText = line + '\n';
                } else {
                    currentPageText += line + '\n';
                }
            }
            if (currentPageText.trim().length > 0) pages.push(currentPageText.trim());
            document.body.removeChild(testDiv);
            console.log(`텍스트 분할 완료: ${pages.length} 페이지`); // 디버깅 로그
            return pages;
        }

        function preloadPages() {
            renderedPages = [];
            const range = Math.min(2, parseInt(preloadRange.value) || 2);
            const start = Math.max(0, currentPage - range);
            const end = Math.min(pages.length, currentPage + range + 1);
            for (let i = start; i < end; i++) {
                const text = pages[i];
                const lines = text.split('\n').filter(line => line.trim().length > 0);
                const html = lines.map(line => {
                    const chars = line.split('');
                    return `<div class="line">${chars.map(char => char.trim() === '' ? `<span class="char-span char-space">${char}</span>` : `<span class="char-span">${char}</span>`).join('')}</div>`;
                }).join('');
                renderedPages[i] = html;
            }
            Object.keys(renderedPages).forEach(key => {
                const pageNum = parseInt(key);
                if (pageNum < start || pageNum >= end) {
                    delete renderedPages[pageNum];
                }
            });
            console.log(`페이지 프리로드 완료: ${start} ~ ${end-1}`); // 디버깅 로그
        }

        function displayPage(direction = 0) {
            const fragment = document.createDocumentFragment();
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = renderedPages[currentPage] || '';
            while (tempDiv.firstChild) fragment.appendChild(tempDiv.firstChild);
            textContent.innerHTML = '';
            textContent.appendChild(fragment);

            pageInfo.innerText = (showPageInfo.checked || isFullscreen) ? `${currentPage + 1}/${pages.length}` : '';
            pageInfo.style.fontSize = `${pageInfoSize.value}px`;
            updatePageInfoStyles();
            progress.value = 0;
            updateProgressPercent(0);
            if (pageAnimation.checked && direction !== 0) {
                textContent.style.transform = direction > 0 ? 'translateX(-100%)' : 'translateX(100%)';
                textContent.style.opacity = 0;
                setTimeout(() => {
                    textContent.style.transform = 'translateX(0)';
                    textContent.style.opacity = 1;
                    if (autoRestart.checked && isTrainingActive && !isPaused) startEffect();
                }, 300);
            } else if (autoRestart.checked && isTrainingActive && !isPaused) {
                startEffect();
            }
            preloadPages();
            saveLastPage();
            console.log(`현재 페이지 표시됨: ${currentPage + 1}/${pages.length}`); // 디버깅 로그
        }

        function loadLastPage() {
            const lastPage = localStorage.getItem(`lastPage_${lastFileName}`);
            currentPage = lastPage ? parseInt(lastPage) : 0;
            currentPage = Math.max(0, Math.min(currentPage, pages.length - 1));
            console.log(`마지막 페이지 로드: ${currentPage + 1}`); // 디버깅 로그
        }

        function saveLastPage() {
            localStorage.setItem(`lastPage_${lastFileName}`, currentPage);
        }

        // 더블탭 이벤트
        textContent.addEventListener('dblclick', togglePause);
        textContent.addEventListener('touchstart', (e) => {
            const currentTime = Date.now();
            if (currentTime - lastTouchTime < 300) {
                togglePause();
                e.preventDefault();
                console.log('더블탭 감지: 일시정지 토글'); // 디버깅 로그
            }
            lastTouchTime = currentTime;
        });

        function togglePause() {
            if (!pages.length) return;
            isPaused = !isPaused;
            if (isPaused) {
                stopEffect();
                showPauseUI();
                showMessage('일시정지됨', 1000);
                if (timerInterval) {
                    timer.pause();
                    console.log('더블탭으로 타이머 일시정지'); // 디버깅 로그
                }
            } else {
                hidePauseUI();
                if (isTrainingActive) startEffect();
                showMessage('재개됨', 1000);
                if (timerInterval) {
                    timer.resume();
                    console.log('더블탭으로 타이머 재개'); // 디버깅 로그
                }
            }
            console.log(`일시정지 상태: ${isPaused}, 현재 인덱스: ${currentEffectIndex}`); // 디버깅 로그
        }

        function showPauseUI() {
            if (!sliderContainer) {
                sliderContainer = document.createElement('div');
                sliderContainer.id = 'pauseSliderContainer';
                sliderContainer.style.cssText = `
                    position: fixed;
                    bottom: 0;
                    left: 0;
                    width: 100%;
                    z-index: 1000;
                    background: rgba(255, 255, 255, 0.9);
                    padding: 10px;
                    box-sizing: border-box;
                `;
                const slider = document.createElement('input');
                slider.type = 'range';
                slider.min = 1;
                slider.max = pages.length;
                slider.value = currentPage + 1;
                slider.step = 1;
                slider.style.width = '100%';
                slider.addEventListener('input', (e) => {
                    currentPage = parseInt(e.target.value) - 1;
                    displayPage();
                    console.log(`슬라이더로 페이지 이동: ${currentPage + 1}`); // 디버깅 로그
                });
                sliderContainer.appendChild(slider);
                document.body.appendChild(sliderContainer);
            } else {
                sliderContainer.querySelector('input').value = currentPage + 1;
            }
            sliderContainer.style.display = 'block';
            timerSettings.style.display = 'block';
            timerProgress.style.display = 'block';
            pageInfoContainer.style.bottom = '50px';
            speedDownButton.style.display = 'block';
            speedUpButton.style.display = 'block';
            tocButton.style.display = 'block'; // 일시정지 모드에서 목차 버튼 표시
            console.log('일시정지 UI 표시됨'); // 디버깅 로그
        }

        function hidePauseUI() {
            if (sliderContainer) sliderContainer.style.display = 'none';
            timerSettings.style.display = 'none';
            timerProgress.style.display = 'none';
            pageInfoContainer.style.bottom = '10px';
            speedDownButton.style.display = 'none';
            speedUpButton.style.display = 'none';
            tocButton.style.display = 'inline-block'; // 기본 상태로 복귀
            console.log('일시정지 UI 숨김'); // 디버깅 로그
        }

        toggleButton.addEventListener('click', () => {
            if (!isTrainingActive) {
                if (fullscreenMode.checked) {
                    const requestFullscreen = document.documentElement.requestFullscreen || document.documentElement.webkitRequestFullscreen;
                    if (!document.fullscreenElement && requestFullscreen) {
                        requestFullscreen.call(document.documentElement).then(() => {
                            document.body.style.opacity = 0;
                            setTimeout(() => {
                                document.body.classList.add('fullscreen');
                                document.body.style.opacity = 1;
                                if (noSleep) noSleep.enable();
                                isFullscreen = true;
                                updateFullScreenButtons();
                                startEffect();
                            }, 300);
                        }).catch(() => {
                            showMessage('전체화면 모드 활성화 실패.', 5000);
                        });
                    }
                } else {
                    startEffect();
                }
                toggleButton.innerText = '정지';
                isTrainingActive = true;
            } else {
                stopEffect();
                toggleButton.innerText = '시작';
                isTrainingActive = false;
                exitFullscreen();
                if (timerInterval) {
                    timer.stop();
                    console.log('메인화면 정지 버튼으로 타이머 완전 정지'); // 디버깅 로그
                }
            }
        });

        function startEffect() {
            stopEffect();
            setTimeout(() => {
                if (effectSelect.value === 'char') {
                    const spans = textContent.querySelectorAll('.char-span:not(.char-space)');
                    let charIndex = currentEffectIndex;
                    const totalChars = spans.length;
                    const intervalTime = parseInt(speedControl.value) / 2;
                    interval = setInterval(() => {
                        if (charIndex < spans.length) {
                            spans[charIndex].classList.add('fade');
                            charIndex++;
                            currentEffectIndex = charIndex;
                            progress.value = (charIndex / totalChars) * 100;
                            updateProgressPercent(progress.value);
                            totalReadChars++;
                            speedSum += parseInt(speedControl.value);
                            speedCount++;
                        } else {
                            clearInterval(interval);
                            currentEffectIndex = 0;
                            if (autoPageTurn.checked && currentPage < pages.length - 1) {
                                currentPage++;
                                displayPage(1);
                            }
                        }
                    }, intervalTime);
                } else if (effectSelect.value === 'fade') {
                    const lines = textContent.querySelectorAll('.line');
                    let lineIndex = currentEffectIndex;
                    const totalLines = lines.length;
                    const intervalTime = parseInt(speedControl.value);
                    interval = setInterval(() => {
                        if (lineIndex < lines.length) {
                            lines[lineIndex].classList.add('hidden');
                            lineIndex++;
                            currentEffectIndex = lineIndex;
                            progress.value = (lineIndex / totalLines) * 100;
                            updateProgressPercent(progress.value);
                            totalReadChars += lines[lineIndex - 1].textContent.length;
                            speedSum += parseInt(speedControl.value);
                            speedCount++;
                        } else {
                            clearInterval(interval);
                            currentEffectIndex = 0;
                            if (autoPageTurn.checked && currentPage < pages.length - 1) {
                                currentPage++;
                                displayPage(1);
                            }
                        }
                    }, intervalTime);
                } else if (effectSelect.value === 'eink') {
                    const spans = textContent.querySelectorAll('.char-span:not(.char-space)');
                    let charIndex = currentEffectIndex;
                    const totalChars = spans.length;
                    const intervalTime = parseInt(speedControl.value) / 2;
                    textContent.classList.add('eink-mode');
                    interval = setInterval(() => {
                        if (charIndex < spans.length) {
                            spans[charIndex].classList.add('eink-black');
                            charIndex++;
                            currentEffectIndex = charIndex;
                            progress.value = (charIndex / totalChars) * 100;
                            updateProgressPercent(progress.value);
                            totalReadChars++;
                            speedSum += parseInt(speedControl.value);
                            speedCount++;
                        } else {
                            clearInterval(interval);
                            currentEffectIndex = 0;
                            if (autoPageTurn.checked && currentPage < pages.length - 1) {
                                currentPage++;
                                displayPage(1);
                            }
                        }
                    }, intervalTime);
                }
                console.log(`효과 시작, 시작 인덱스: ${currentEffectIndex}`); // 디버깅 로그
            }, parseInt(delayBeforeEffect.value));
        }

        function stopEffect() {
            if (interval) clearInterval(interval);
            interval = null;
            console.log(`효과 중지, 현재 인덱스: ${currentEffectIndex}`); // 디버깅 로그
        }

        function exitFullscreen() {
            const exitFullscreen = document.exitFullscreen || document.webkitExitFullscreen;
            if (document.fullscreenElement && exitFullscreen) {
                document.body.style.opacity = 0;
                setTimeout(() => {
                    exitFullscreen.call(document).then(() => {
                        document.body.classList.remove('fullscreen');
                        document.body.style.opacity = 1;
                        if (noSleep) noSleep.disable();
                        isFullscreen = false;
                        updateFullScreenButtons();
                    }).catch(() => {
                        showMessage('전체화면 모드 종료 실패.', 5000);
                    });
                }, 300);
            }
        }

        pageInfo.addEventListener('click', () => {
            stopEffect();
            exitFullscreen();
        });

        speedDownButton.addEventListener('click', () => {
            if (!isPaused) return;
            stopEffect();
            let newSpeed = Math.max(50, parseInt(speedControl.value) - 5);
            speedControl.value = newSpeed;
            speedInput.value = newSpeed;
            speedPreset.value = newSpeed;
            adjustSpeed();
            localStorage.setItem('speed', newSpeed);
            showMessage(`속도: ${newSpeed}ms`, 1000);
            console.log(`속도 감소: ${newSpeed}ms`); // 디버깅 로그
        });

        speedUpButton.addEventListener('click', () => {
            if (!isPaused) return;
            stopEffect();
            let newSpeed = Math.min(2000, parseInt(speedControl.value) + 5);
            speedControl.value = newSpeed;
            speedInput.value = newSpeed;
            speedPreset.value = newSpeed;
            adjustSpeed();
            localStorage.setItem('speed', newSpeed);
            showMessage(`속도: ${newSpeed}ms`, 1000);
            console.log(`속도 증가: ${newSpeed}ms`); // 디버깅 로그
        });

        leftPageButton.addEventListener('click', () => {
            if (currentPage > 0) {
                currentPage--;
                stopEffect();
                displayPage(-1);
                if (isTrainingActive && !isPaused) startEffect();
            }
        });

        rightPageButton.addEventListener('click', () => {
            if (currentPage < pages.length - 1) {
                currentPage++;
                stopEffect();
                displayPage(1);
                if (isTrainingActive && !isPaused) startEffect();
            }
        });

        // SyntaxError 해결: zelenýId 대신 tocButton 사용
        tocButton.addEventListener('click', showToc);

        // 모바일 페이지 넘김
        let touchStartX = 0;
        textContent.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
        });

        textContent.addEventListener('touchend', (e) => {
            if (isPaused) return;
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const deltaX = touchEndX - touchStartX;
            const windowHeight = window.innerHeight;

            if (mobileSpeedControl.checked && touchEndY > windowHeight * 0.8) {
                if (touchEndX > window.innerWidth * 0.75) {
                    let newSpeed = Math.max(50, parseInt(speedControl.value) - 5);
                    speedControl.value = newSpeed;
                    speedInput.value = newSpeed;
                    speedPreset.value = newSpeed;
                    adjustSpeed();
                    localStorage.setItem('speed', newSpeed);
                    showMessage(`속도: ${newSpeed}ms`, 1000);
                    if (isTrainingActive && !isPaused) startEffect();
                } else if (touchEndX < window.innerWidth * 0.25) {
                    let newSpeed = Math.min(2000, parseInt(speedControl.value) + 5);
                    speedControl.value = newSpeed;
                    speedInput.value = newSpeed;
                    speedPreset.value = newSpeed;
                    adjustSpeed();
                    localStorage.setItem('speed', newSpeed);
                    showMessage(`속도: ${newSpeed}ms`, 1000);
                    if (isTrainingActive && !isPaused) startEffect();
                }
            } else if (isPageTurning) {
                console.log('페이지 넘김 중복 감지, 무시됨'); // 디버깅 로그
                return;
            } else if (deltaX > 100 && currentPage > 0) {
                isPageTurning = true;
                currentPage--;
                stopEffect();
                displayPage(-1);
                if (isTrainingActive && !isPaused) startEffect();
                setTimeout(() => isPageTurning = false, 300);
                console.log(`페이지 이동 (이전): ${currentPage + 1}`); // 디버깅 로그
            } else if (deltaX < -100 && currentPage < pages.length - 1) {
                isPageTurning = true;
                currentPage++;
                stopEffect();
                displayPage(1);
                if (isTrainingActive && !isPaused) startEffect();
                setTimeout(() => isPageTurning = false, 300);
                console.log(`페이지 이동 (다음): ${currentPage + 1}`); // 디버깅 로그
            }
            e.preventDefault();
        });

        // 타이머 설정 관련 함수들
        addSetConfig.addEventListener('click', () => {
            const newConfig = document.createElement('div');
            newConfig.className = 'setConfig';
            newConfig.innerHTML = `
                <label>읽는 시간 (분:초):</label>
                <input type="number" class="readMinutes" min="0" value="0">
                <input type="number" class="readSeconds" min="0" max="59" value="0">
                <label>일시정지 시간 (분:초):</label>
                <input type="number" class="pauseMinutes" min="0" value="0">
                <input type="number" class="pauseSeconds" min="0" max="59" value="0">
                <label>대기 시간 (초):</label>
                <input type="number" class="waitTime" min="0" value="0">
                <button class="removeConfig">제거</button>
            `;
            setConfigs.appendChild(newConfig);
            newConfig.querySelector('.removeConfig').addEventListener('click', () => {
                setConfigs.removeChild(newConfig);
                console.log('세트 구성 제거됨'); // 디버깅 로그
            });
            console.log('새로운 세트 구성 추가됨'); // 디버깅 로그
        });

        saveConfig.addEventListener('click', () => {
            const config = {
                setCount: setCount.value,
                setConfigs: Array.from(setConfigs.querySelectorAll('.setConfig')).map(config => ({
                    readMinutes: config.querySelector('.readMinutes').value,
                    readSeconds: config.querySelector('.readSeconds').value,
                    pauseMinutes: config.querySelector('.pauseMinutes').value,
                    pauseSeconds: config.querySelector('.pauseSeconds').value,
                    waitTime: config.querySelector('.waitTime').value
                })),
                startSound: startSound.value,
                readEndSound: readEndSound.value,
                pauseEndSound: pauseEndSound.value,
                allSetsEndSound: allSetsEndSound.value
            };
            localStorage.setItem('timerConfig', JSON.stringify(config));
            showMessage('타이머 구성이 저장되었습니다.', 2000);
            console.log('타이머 구성 저장됨:', config); // 디버깅 로그
        });

        loadConfig.addEventListener('click', () => {
            const config = JSON.parse(localStorage.getItem('timerConfig'));
            if (config) {
                setCount.value = config.setCount;
                setConfigs.innerHTML = '';
                config.setConfigs.forEach(conf => {
                    const newConfig = document.createElement('div');
                    newConfig.className = 'setConfig';
                    newConfig.innerHTML = `
                        <label>읽는 시간 (분:초):</label>
                        <input type="number" class="readMinutes" min="0" value="${conf.readMinutes}">
                        <input type="number" class="readSeconds" min="0" max="59" value="${conf.readSeconds}">
                        <label>일시정지 시간 (분:초):</label>
                        <input type="number" class="pauseMinutes" min="0" value="${conf.pauseMinutes}">
                        <input type="number" class="pauseSeconds" min="0" max="59" value="${conf.pauseSeconds}">
                        <label>대기 시간 (초):</label>
                        <input type="number" class="waitTime" min="0" value="${conf.waitTime}">
                        <button class="removeConfig">제거</button>
                    `;
                    setConfigs.appendChild(newConfig);
                    newConfig.querySelector('.removeConfig').addEventListener('click', () => {
                        setConfigs.removeChild(newConfig);
                        console.log('세트 구성 제거됨'); // 디버깅 로그
                    });
                });
                startSound.value = config.startSound || '';
                readEndSound.value = config.readEndSound || '';
                pauseEndSound.value = config.pauseEndSound || '';
                allSetsEndSound.value = config.allSetsEndSound || '';
                showMessage('타이머 구성이 불러와졌습니다.', 2000);
                console.log('타이머 구성 불러옴:', config); // 디버깅 로그
            } else {
                showMessage('저장된 타이머 구성이 없습니다.', 2000);
                console.log('저장된 타이머 구성 없음'); // 디버깅 로그
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            loadConfig.click(); // 페이지 로드 시 자동으로 마지막 타이머 구성 불러오기
            console.log('페이지 로드 시 타이머 구성 자동 불러옴'); // 디버깅 로그
        });

        function playSynthesizedSound() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            const oscillator = audioContext.createOscillator();
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4 음
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(1, audioContext.currentTime + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1);
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 1);
            console.log('피아노 음 재생됨'); // 디버깅 로그
        }

        function playSound(soundFile) {
            if (soundFile) {
                if (soundFile === 'piano') {
                    playSynthesizedSound();
                } else {
                    const audio = new Audio(`sounds/${soundFile}`);
                    audio.play().catch(e => console.error('사운드 재생 오류:', e));
                }
            }
        }

        function parseTime(minutes, seconds) {
            const min = parseInt(minutes) || 0;
            const sec = Math.min(59, Math.max(0, parseInt(seconds) || 0));
            return (min * 60 + sec) * 1000;
        }

        class Timer {
            constructor() {
                this.startTime = 0;
                this.duration = 0;
                this.callback = null;
                this.timerId = null;
                this.paused = false;
                this.remaining = 0;
            }

            start(duration, callback) {
                this.stop();
                this.startTime = performance.now();
                this.duration = duration;
                this.callback = callback;
                this.timerId = setTimeout(() => {
                    if (this.callback) this.callback();
                }, duration);
                console.log(`타이머 시작: ${duration / 1000}초 설정됨`); // 디버깅 로그
            }

            pause() {
                if (this.timerId) {
                    clearTimeout(this.timerId);
                    this.remaining = this.duration - (performance.now() - this.startTime);
                    this.paused = true;
                    console.log(`타이머 일시정지: ${this.remaining / 1000}초 남음`); // 디버깅 로그
                }
            }

            resume() {
                if (this.paused) {
                    this.startTime = performance.now();
                    this.timerId = setTimeout(() => {
                        if (this.callback) this.callback();
                    }, this.remaining);
                    this.paused = false;
                    console.log(`타이머 재개: ${this.remaining / 1000}초 남음`); // 디버깅 로그
                }
            }

            stop() {
                if (this.timerId) {
                    clearTimeout(this.timerId);
                    this.timerId = null;
                    console.log('타이머 정지됨'); // 디버깅 로그
                }
            }
        }

        const timer = new Timer();

        function startTimer() {
            if (timerInterval) {
                console.log('이미 타이머가 실행 중입니다.'); // 디버깅 로그
                return;
            }
            totalSets = parseInt(setCount.value);
            configs = Array.from(setConfigs.querySelectorAll('.setConfig')).map(config => ({
                readTime: parseTime(config.querySelector('.readMinutes').value, config.querySelector('.readSeconds').value),
                pauseTime: parseTime(config.querySelector('.pauseMinutes').value, config.querySelector('.pauseSeconds').value),
                waitTime: parseInt(config.querySelector('.waitTime').value) * 1000
            }));
            if (configs.length === 0) {
                showMessage('세트 구성을 추가해주세요.', 2000);
                console.log('세트 구성 없음'); // 디버깅 로그
                return;
            }

            currentSet = 0;
            currentConfigIndex = 0;
            isReading = true;
            timerStartTime = performance.now();
            totalReadChars = 0;
            totalReadTime = 0;
            speedSum = 0;
            speedCount = 0;

            startWaitTime = configs[0].waitTime;
            if (startWaitTime > 0) {
                timer.start(startWaitTime, () => {
                    playSound(startSound.value); // 대기 시간 후 시작 소리 재생
                    console.log('대기 시간 종료 후 시작 소리 재생됨'); // 디버깅 로그
                    runSet();
                });
                console.log(`시작 대기 시간: ${startWaitTime / 1000}초`); // 디버깅 로그
            } else {
                playSound(startSound.value); // 대기 시간이 없으면 즉시 시작 소리
                console.log('대기 시간 없음, 즉시 시작 소리 재생됨'); // 디버깅 로그
                runSet();
            }
        }

        function runSet() {
            if (currentSet >= totalSets) {
                playSound(allSetsEndSound.value);
                showMessage('타이머가 완료되었습니다.', 2000);
                console.log('타이머 완료'); // 디버깅 로그
                timerInterval = null;
                saveRecord();
                return;
            }

            const currentConfig = configs[currentConfigIndex];
            const duration = isReading ? currentConfig.readTime : currentConfig.pauseTime;

            if (isReading) {
                if (isPaused) togglePause();
                console.log(`읽기 시간 시작: ${duration / 1000}초`); // 디버깅 로그
            } else {
                if (!isPaused) togglePause();
                console.log(`일시정지 시간 시작: ${duration / 1000}초`); // 디버깅 로그
            }

            timer.start(duration, () => {
                if (isReading) {
                    playSound(readEndSound.value);
                } else {
                    playSound(pauseEndSound.value);
                }
                isReading = !isReading;
                if (isReading) {
                    currentConfigIndex++;
                    if (currentConfigIndex >= configs.length) {
                        currentConfigIndex = 0;
                        currentSet++;
                        console.log(`세트 완료: ${currentSet}/${totalSets}`); // 디버깅 로그
                    }
                    const nextWaitTime = configs[currentConfigIndex].waitTime;
                    if (nextWaitTime > 0) {
                        timer.start(nextWaitTime, () => {
                            playSound(startSound.value); // 다음 세트 시작 시 소리 재생
                            console.log('세트 간 대기 후 시작 소리 재생됨'); // 디버깅 로그
                            runSet();
                        });
                        console.log(`세트 간 대기 시간: ${nextWaitTime / 1000}초`); // 디버깅 로그
                    } else {
                        runSet();
                    }
                } else {
                    runSet();
                }
            });
        }

        startTimerButton.addEventListener('click', () => {
            if (timer.paused) {
                timer.resume();
                showMessage('타이머가 재개되었습니다.', 2000);
                console.log('시작 버튼으로 타이머 재개'); // 디버깅 로그
            } else {
                startTimer();
            }
        });

        pauseTimerButton.addEventListener('click', () => {
            if (timer.paused) {
                timer.resume();
                showMessage('타이머가 재개되었습니다.', 2000);
                console.log('일시정지 버튼으로 타이머 재개'); // 디버깅 로그
            } else {
                timer.pause();
                showMessage('타이머가 일시정지되었습니다.', 2000);
                console.log('일시정지 버튼으로 타이머 일시정지'); // 디버깅 로그
            }
        });

        stopTimerButton.addEventListener('click', () => {
            timer.stop();
            if (isPaused) togglePause();
            showMessage('타이머가 정지되었습니다.', 2000);
            console.log('정지 버튼으로 타이머 완전 정지'); // 디버깅 로그
        });

        setInterval(() => {
            if (timerInterval) {
                const elapsed = (performance.now() - timerStartTime) / 1000;
                timerStatus.innerText = `세트 ${currentSet + 1}/${totalSets}, ${isReading ? '읽기' : '일시정지'} 중`;
                readChars.innerText = totalReadChars;
                avgSpeed.innerText = speedCount > 0 ? (speedSum / speedCount).toFixed(2) : 0;
                elapsedTime.innerText = elapsed.toFixed(2);
            }
        }, 1000);

        function saveRecord() {
            const record = {
                timestamp: Date.now(),
                totalReadChars,
                avgSpeed: speedCount > 0 ? speedSum / speedCount : 0,
                totalReadTime: (performance.now() - timerStartTime) / 1000,
                setCount: totalSets,
                configs: configs
            };
            records.push(record);
            localStorage.setItem('records', JSON.stringify(records));
            showMessage('기록이 저장되었습니다.', 2000);
            console.log('기록 저장됨:', record); // 디버깅 로그
        }

        recordButton.addEventListener('click', () => {
            recordList.style.display = recordList.style.display === 'block' ? 'none' : 'block';
            recordList.querySelector('ul').innerHTML = records.map(record => `
                <li>
                    <p>날짜: ${new Date(record.timestamp).toLocaleString()}</p>
                    <p>읽은 글자 수: ${record.totalReadChars}</p>
                    <p>평균 속도: ${record.avgSpeed.toFixed(2)}ms</p>
                    <p>총 읽기 시간: ${record.totalReadTime.toFixed(2)}초</p>
                    <p>세트 수: ${record.setCount}</p>
                </li>
            `).join('');
            console.log('기록 목록 표시됨'); // 디버깅 로그
        });

        bookmarkButton.addEventListener('click', () => {
            const bookmark = {
                fileName: lastFileName,
                page: currentPage,
                timestamp: Date.now()
            };
            bookmarks.push(bookmark);
            localStorage.setItem('bookmarks', JSON.stringify(bookmarks));
            showMessage('북마크가 추가되었습니다.', 2000);
            updateBookmarkList();
            console.log('북마크 추가됨:', bookmark); // 디버깅 로그
        });

        function updateBookmarkList() {
            bookmarkList.querySelector('ul').innerHTML = bookmarks.map((bookmark, index) => `
                <li onclick="jumpToBookmark(${index})">${bookmark.fileName} - 페이지 ${bookmark.page + 1}</li>
            `).join('');
            bookmarkList.style.display = 'block';
            bookmarkList.addEventListener('click', () => {
                bookmarkList.style.display = 'none';
                console.log('북마크 목록 클릭으로 숨김'); // 디버깅 로그
            });
            document.addEventListener('click', (e) => {
                if (!bookmarkList.contains(e.target) && e.target !== bookmarkButton) {
                    bookmarkList.style.display = 'none';
                    console.log('외부 클릭으로 북마크 목록 숨김'); // 디버깅 로그
                }
            }, { once: true });
            console.log('북마크 목록 업데이트 및 표시됨'); // 디버깅 로그
        }

        async function jumpToBookmark(index) {
            const bookmark = bookmarks[index];
            if (bookmark.fileName !== lastFileName) {
                const file = libraryFiles.find(f => f.name === bookmark.fileName);
                if (file) {
                    await handleFileUpload(new File([file.data], file.name));
                } else {
                    showMessage('북마크 파일을 찾을 수 없습니다.', 2000);
                    console.error(`북마크 파일 로드 실패: ${bookmark.fileName}`); // 디버깅 로그
                    return;
                }
            }
            currentPage = bookmark.page;
            displayPage();
            showMessage('북마크로 이동했습니다.', 2000);
            console.log(`북마크로 이동: ${bookmark.fileName}, 페이지 ${bookmark.page + 1}`); // 디버깅 로그
        }

        libraryButton.addEventListener('click', showLibrary);
        favoritesButton.addEventListener('click', showFavorites);

        function showLibrary() {
            libraryOverlay.style.display = 'block';
            updateLibraryContent();
            console.log('라이브러리 표시됨'); // 디버깅 로그
        }

        function showFavorites() {
            favoritesOverlay.style.display = 'block';
            updateFavoritesContent();
            console.log('즐겨찾기 표시됨'); // 디버깅 로그
        }

        function updateLibraryContent() {
            const searchTerm = document.getElementById('librarySearch').value.toLowerCase();
            const sortBy = document.getElementById('librarySort').value;
            const filteredFiles = libraryFiles.filter(file => file.name.toLowerCase().includes(searchTerm));
            filteredFiles.sort((a, b) => {
                if (sortBy === 'recent') return b.timestamp - a.timestamp;
                if (sortBy === 'name') return a.name.localeCompare(b.name);
                if (sortBy === 'title') return (a.title || a.name).localeCompare(b.title || b.name);
                if (sortBy === 'added') return a.timestamp - b.timestamp;
            });
            libraryContent.innerHTML = filteredFiles.map(file => `
                <div class="library-item">
                    ${file.cover ? `<img src="${file.cover}" alt="Cover">` : `<div class="no-cover">No Cover</div>`}
                    <span onclick="loadFileFromLibrary('${file.name}')">${file.name}</span>
                    <button onclick="deleteFromLibrary('${file.name}')">삭제</button>
                    <button class="favorite-button ${file.isFavorite ? 'favorited' : ''}" onclick="toggleFavorite('${file.name}')">★</button>
                </div>
            `).join('');
            console.log(`라이브러리 목록 업데이트됨: ${filteredFiles.length}개 항목`); // 디버깅 로그
        }

        function updateFavoritesContent() {
            const searchTerm = document.getElementById('favoritesSearch').value.toLowerCase();
            const sortBy = document.getElementById('favoritesSort').value;
            const filteredFavorites = favorites.filter(file => file.name.toLowerCase().includes(searchTerm));
            filteredFavorites.sort((a, b) => {
                if (sortBy === 'recent') return b.timestamp - a.timestamp;
                if (sortBy === 'name') return a.name.localeCompare(b.name);
                if (sortBy === 'title') return (a.title || a.name).localeCompare(b.title || b.name);
                if (sortBy === 'added') return a.timestamp - b.timestamp;
            });
            favoritesContent.innerHTML = filteredFavorites.map(file => `
                <div class="favorites-item">
                    ${file.cover ? `<img src="${file.cover}" alt="Cover">` : `<div class="no-cover">No Cover</div>`}
                    <span onclick="loadFileFromLibrary('${file.name}')">${file.name}</span>
                    <button class="favorite-button favorited" onclick="toggleFavorite('${file.name}')">★</button>
                </div>
            `).join('');
            console.log(`즐겨찾기 목록 업데이트됨: ${filteredFavorites.length}개 항목`); // 디버깅 로그
        }

        function toggleFavorite(fileName) {
            const file = libraryFiles.find(f => f.name === fileName);
            if (file) {
                file.isFavorite = !file.isFavorite;
                if (file.isFavorite) {
                    favorites.push(file);
                } else {
                    favorites = favorites.filter(f => f.name !== fileName);
                }
                localStorage.setItem('favorites', JSON.stringify(favorites));
                localStorage.setItem('libraryFiles', JSON.stringify(libraryFiles));
                updateLibraryContent();
                updateFavoritesContent();
                console.log(`즐겨찾기 토글: ${fileName}, 상태: ${file.isFavorite}`); // 디버깅 로그
            }
        }

        async function loadFileFromLibrary(fileName) {
            const file = libraryFiles.find(f => f.name === fileName);
            if (file) {
                await handleFileUpload(new File([file.data], file.name));
                showMessage('파일이 로드되었습니다.', 2000);
                libraryOverlay.style.display = 'none'; // 메인 화면으로 복귀
                console.log(`라이브러리에서 파일 로드됨: ${fileName}`); // 디버깅 로그
            } else {
                showMessage('파일을 찾을 수 없습니다.', 2000);
                console.error(`파일 로드 실패: ${fileName}`); // 디버깅 로그
            }
        }

        function deleteFromLibrary(fileName) {
            libraryFiles = libraryFiles.filter(f => f.name !== fileName);
            favorites = favorites.filter(f => f.name !== fileName); // 즐겨찾기에서도 제거
            localStorage.setItem('libraryFiles', JSON.stringify(libraryFiles));
            localStorage.setItem('favorites', JSON.stringify(favorites));
            updateLibraryContent();
            showMessage('파일이 라이브러리에서 삭제되었습니다.', 2000);
            console.log(`라이브러리에서 파일 삭제됨: ${fileName}`); // 디버깅 로그
        }

        document.getElementById('addFilesButton').addEventListener('click', () => {
            fileInput.click();
            console.log('파일/폴더 추가 버튼 클릭됨'); // 디버깅 로그
        });

        function updateTextContentStyles() {
            document.documentElement.style.setProperty('--font-size', `${fontSize.value}px`);
            document.documentElement.style.setProperty('--line-height', lineHeight.value);
            document.documentElement.style.setProperty('--letter-spacing', `${letterSpacing.value}px`);
            document.documentElement.style.setProperty('--text-height', `${textHeight.value}vh`);
            document.documentElement.style.setProperty('--margin-top', `${marginTop.value}vh`);
            document.documentElement.style.setProperty('--margin-right', `${marginRight.value}vw`);
            document.documentElement.style.setProperty('--margin-bottom', `${marginBottom.value}vh`);
            document.documentElement.style.setProperty('--margin-left', `${marginLeft.value}vw`);
            textContent.style.fontFamily = fontFamily.value;
        }

        function toggleBlackMode() {
            if (blackMode.checked) {
                document.body.classList.add('black-mode');
                textContent.style.backgroundColor = blackModeColor.value;
            } else {
                document.body.classList.remove('black-mode');
                textContent.style.backgroundColor = '#fff';
            }
        }

        function updateFullScreenButtons() {
            leftPageButton.style.width = `${fullScreenButtonWidth.value}vw`;
            rightPageButton.style.width = `${fullScreenButtonWidth.value}vw`;
            leftPageButton.style.height = `${fullScreenButtonHeight.value}vh`;
            rightPageButton.style.height = `${fullScreenButtonHeight.value}vh`;
            leftPageButton.style.display = enableFullScreenButtons.checked && isFullscreen ? 'block' : 'none';
            rightPageButton.style.display = enableFullScreenButtons.checked && isFullscreen ? 'block' : 'none';
        }

        function updatePageInfoStyles() {
            pageInfo.style.opacity = pageInfoOpacity.value;
            speedDownButton.style.opacity = pageInfoOpacity.value;
            speedUpButton.style.opacity = pageInfoOpacity.value;
        }

        function updateProgressPercent(value) {
            progressPercent.innerText = `${Math.round(value)}%`;
            progressPercent.style.display = showProgress.checked ? 'block' : 'none';
        }

        function adjustSpeed() {
            // 속도 조정 로직 (필요 시 추가)
        }

        function toggleButtons(disable) {
            toggleButton.disabled = disable;
            tocButton.disabled = disable;
            libraryButton.disabled = disable;
            favoritesButton.disabled = disable;
            bookmarkButton.disabled = disable;
            recordButton.disabled = disable;
            jumpToPage.disabled = disable;
        }

        function showToc() {
            tocOverlay.style.display = 'block';
            if (toc.length === 0) {
                tocContent.innerHTML = '<p>목차가 없습니다.</p>';
                console.log('목차 데이터 없음'); // 디버깅 로그
            } else {
                tocContent.innerHTML = '<ul>' + toc.map(item => `
                    <li onclick="jumpToSection('${item.href}')">${item.label} (페이지: ${item.href})</li>
                `).join('') + '</ul>';
                console.log(`목차 표시됨, 항목 수: ${toc.length}`); // 디버깅 로그
            }
        }

        function jumpToSection(href) {
            if (book && href) {
                book.rendition.display(href).then(() => {
                    currentPage = book.rendition.location.start.displayed.page - 1;
                    displayPage();
                    console.log(`목차로 이동 성공: ${href}, 페이지: ${currentPage + 1}`); // 디버깅 로그
                }).catch(err => {
                    console.error(`목차 이동 실패: ${err}`); // 디버깅 로그
                    showMessage('목차 이동 실패', 5000);
                });
            } else {
                console.warn('EPUB 책 객체 없음 또는 href 누락'); // 디버깅 로그
            }
            tocOverlay.style.display = 'none';
        }

        resetSettings.addEventListener('click', () => {
            localStorage.clear();
            location.reload();
            console.log('설정 초기화됨'); // 디버깅 로그
        });

        clearCacheButton.addEventListener('click', async () => {
            await clearIndexedDBCache();
            libraryFiles = [];
            localStorage.setItem('libraryFiles', JSON.stringify(libraryFiles));
            showMessage('캐시가 비워졌습니다.', 2000);
            console.log('캐시 비워짐'); // 디버깅 로그
        });

        document.getElementById('closeToc').addEventListener('click', () => {
            tocOverlay.style.display = 'none';
            console.log('목차 닫힘'); // 디버깅 로그
        });

        document.getElementById('closeLibrary').addEventListener('click', () => {
            libraryOverlay.style.display = 'none';
            console.log('라이브러리 닫힘'); // 디버깅 로그
        });

        document.getElementById('closeFavorites').addEventListener('click', () => {
            favoritesOverlay.style.display = 'none';
            console.log('즐겨찾기 닫힘'); // 디버깅 로그
        });
    </script>
</body>
</html>
